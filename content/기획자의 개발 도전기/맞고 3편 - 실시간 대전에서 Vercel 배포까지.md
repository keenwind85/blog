---
title: "[기획자의 개발 도전기] 맞고 3편 - 실시간 대전에서 Vercel 배포까지"
date: 2026-02-19
tags:
  - 바이브코딩
  - Flutter
  - FlutterWeb
  - Firebase
  - Vercel
  - 맞고
---

# 실시간 대전에서 Vercel 배포까지

## 3000줄의 로직, 이제 두 사람을 연결해야 한다

[[맞고 2편 - 맞고 규칙을 3000줄의 코드로 번역하다|이전 편]]에서 맞고의 게임 로직을 3000줄에 걸쳐 구현한 이야기를 했다. 하지만 로직만으로는 게임이 안 된다. 맞고는 **2인 대전** 게임이다. 내가 패를 내면 상대방 화면에 즉시 반영되어야 하고, 상대가 고를 외치면 내 화면에 알림이 떠야 한다.

이번 편에서는 실시간 멀티플레이어 구현, 게임을 게임답게 만드는 아이템과 코인 시스템, 그리고 Flutter Web을 Vercel에 배포하기까지의 여정을 다룬다.

## Firebase Realtime Database — 왜 이걸 골랐나

실시간 동기화에 Firebase Realtime Database를 선택한 이유는 단순하다. **레이턴시**.

| 비교 | Firebase Realtime DB | Firestore | Supabase Realtime |
|------|---------------------|-----------|-------------------|
| 동기화 지연 | ~100ms | ~300ms | ~500ms |
| 데이터 구조 | JSON 트리 | 문서-컬렉션 | PostgreSQL 테이블 |
| 실시간 리스너 | 네이티브 지원 | 네이티브 지원 | WebSocket |
| 가격 | 동시접속 기준 | 읽기/쓰기 기준 | 행 수 기준 |

카드 게임은 초 단위가 아니라 **밀리초 단위**의 동기화가 필요하다. 내가 카드를 내는 순간 상대에게 보여야 하고, 뻑이 발생하면 두 플레이어가 거의 동시에 같은 화면을 봐야 한다. Firestore도 좋지만 게임처럼 상태가 자주 바뀌는 경우엔 Realtime DB가 더 맞다.

순시미네에서 Supabase를 쓰고, 백엔드 리팩토링에서도 Supabase를 썼지만, 이번엔 Firebase다. 도구는 상황에 따라 바꾸는 게 맞다.

## 게임 방 구조

게임의 실시간 데이터 구조는 이렇다:

```
rooms/
  └─ {roomId}/          ← 4자리 방 코드
      ├─ hostUid         ← 방장 UID
      ├─ guestUid        ← 참가자 UID
      ├─ status          ← waiting / playing / finished
      ├─ createdAt       ← 생성 시간 (60분 후 만료)
      └─ gameState/      ← 40개+ 필드의 게임 상태
          ├─ currentTurn
          ├─ deck[]
          ├─ floorCards[]
          ├─ player1Hand[]
          ├─ player1Captured{}
          ├─ player1Score
          ├─ ...
          └─ lastSpecialEvent
```

방 코드는 4자리 영숫자 랜덤 생성이다. "야 방 코드 뭐야?" → "A3K7" → 입력 → 게임 시작. URL 공유로 바로 입장하는 것도 되지만, 직접 코드를 치는 게 더 확실하다.

방 만료는 **60분**으로 설정했다. 맞고 한 판이 보통 5~10분이니 넉넉하다. 만료된 방은 다음 접속 시 정리된다.

## Transaction의 함정 — Flutter Web의 StateError

멀티플레이어 게임에서 가장 중요한 건 **동시 쓰기 충돌 방지**다. 두 플레이어가 동시에 게임 상태를 업데이트하면 데이터가 꼬인다.

Firebase Realtime Database의 `runTransaction`이 이 문제를 해결해준다. 트랜잭션은 "현재 값을 읽고 → 수정하고 → 값이 바뀌지 않았으면 저장"하는 원자적 연산이다.

**그런데 Flutter Web에서 트랜잭션이 깨진다.**

Flutter Web 환경에서 Firebase Transaction 실행 시 `StateError`가 발생하는 알려진 이슈가 있다. 네이티브(iOS/Android)에서는 문제없는데, Web에서만 터진다.

해결법은 **fallback 패턴**이다:

```
트랜잭션 시도
  → 성공: 정상 처리
  → StateError 발생:
      → 현재 값을 직접 읽기 (get)
      → 업데이트 함수 적용
      → 직접 덮어쓰기 (set)
```

트랜잭션이 실패하면, 현재 상태를 수동으로 읽어서 업데이트 함수를 적용하고 `set()`으로 저장한다. 엄밀히 말하면 이 fallback은 원자적이지 않다. 두 플레이어가 정확히 같은 밀리초에 fallback을 탈 경우 충돌이 가능하다. 하지만 맞고는 턴제 게임이라 한 번에 한 명만 조작한다. 실제로 이 fallback에서 문제가 생긴 적은 없다.

이건 AI가 짠 코드를 내가 게임 돌리다 발견한 케이스다. 웹에서 게임이 갑자기 멈추는 현상이 있었고, 로그를 보니 `StateError`가 찍혀 있었다. AI에게 "Flutter Web에서 Firebase Transaction StateError가 뜨는데 해결해줘"라고 했더니, 이 fallback 패턴을 제안했다.

## 클라이언트 사이드 게임 로직 — "신뢰 기반 아키텍처"

일반적으로 멀티플레이어 게임은 **서버에서 게임 로직을 실행**한다. 클라이언트는 입력만 보내고, 서버가 결과를 계산해서 두 클라이언트에 뿌린다. 치팅 방지를 위해서다.

光끼의 맞고는 다르다. **게임 로직이 전부 클라이언트에서 돌아간다.**

```
┌──────────┐                    ┌──────────┐
│ Player 1 │                    │ Player 2 │
│          │                    │          │
│  UI ────────→ 게임 로직 실행    │          │
│          │   결과를 Firebase에  │          │
│          │   ──── 저장 ──────→ │  리스너   │
│          │                    │  ──→ UI  │
│          │                    │  업데이트  │
└──────────┘                    └──────────┘
```

Firebase Realtime Database는 **데이터 저장소**일 뿐, 게임 로직을 실행하지 않는다. 플레이어 1이 카드를 내면, 플레이어 1의 클라이언트가 게임 로직을 돌리고, 결과를 Firebase에 저장하고, 플레이어 2의 리스너가 변경을 감지해서 UI를 업데이트한다.

이런 구조를 선택한 이유:

1. **서버리스** — Firebase만으로 충분, 별도 게임 서버 불필요
2. **비용 절감** — Cloud Functions 비용 없음
3. **개발 속도** — 서버 로직 + 클라이언트 로직 분리 필요 없음

물론 치팅에 취약하다. 하지만 이건 회사 캐릭터로 만든 캐주얼 게임이다. 치팅 방지보다 **10일 안에 동작하는 게임을 만드는 게** 우선이었다.

## 60초 턴 타이머

상대방이 카드를 안 내면 게임이 멈춘다. 이걸 방지하기 위해 **60초 턴 타이머**를 구현했다.

```
턴 시작
  → 60초 카운트다운 (1초 간격)
  → 매 초 UI 업데이트 (남은 시간 표시)
  → 0초 도달:
      → 내 턴이면: 자동 플레이 실행 (autoPlayOnTimeout)
      → 상대 턴이면: 대기 (상대 클라이언트에서 처리)
```

자동 플레이는 랜덤 카드를 내는 게 아니라, 가능한 카드 중 하나를 선택해서 정상적인 턴을 진행한다. 60초가 지나면 AI가 대신 쳐주는 셈이다.

재미있는 건 타이머의 위치다. 턴 타이머는 **각 플레이어의 클라이언트**에서 돌아간다. 서버 타이머가 아니다. 이러면 시계가 약간 어긋날 수 있는데, 맞고 턴에 밀리초 정밀도가 필요한 건 아니라서 문제없다. 아바타 옆에 남은 턴 수가 4 이하면 캐릭터 표정이 초조하게 바뀌는 것도 타이머와 연동된다.

## 아이템 시스템 — 게임에 양념 더하기

맞고 규칙만으로도 게임은 돌아간다. 하지만 반복 플레이의 재미를 위해 **8종 아이템**을 넣었다.

| # | 아이템 | 가격 | 효과 |
|---|--------|------|------|
| 1 | 光끼의 물약 | 50코인 | 광끼 게이지 즉시 100% 충전 |
| 2 | 제발 Go만해! | 30코인 | 상대방 다음 고/스톱에서 Go만 선택 가능 |
| 3 | 제발 Stop만해! | 30코인 | 상대방 다음 고/스톱에서 Stop만 선택 가능 |
| 4 | 우리 패 바꾸자! | 30코인 | 양쪽 플레이어 손패 전체 교환 |
| 5 | 밑장 빼기 | 20코인 | 덱에서 랜덤 1장을 몰래 손패에 추가 |
| 6 | 손패 교체 | 20코인 | 손패를 덱의 랜덤 카드로 교체 |
| 7 | 바닥패 교체 | 20코인 | 바닥패를 덱의 랜덤 카드로 교체 |
| 8 | 光의 기운 | 20코인 | 3턴간 광 카드 우선 배치 |

아이템 상점은 매일 3개씩 랜덤으로 로테이션된다. 타입당 하루 1개만 구매 가능하다. 밸런스보다는 **"이런 것도 있어?"** 하는 재미를 목표로 설계했다.

"제발 Go만해!"와 "제발 Stop만해!"가 특히 재밌다. 상대가 7점을 모아서 고를 외치려는 순간 "제발 Stop만해!"를 쓰면, 상대는 울며 겨자 먹기로 스톱을 선언해야 한다. 반대로 "제발 Go만해!"를 쓰면, 상대가 3점짜리에서 안전하게 스톱하고 싶어도 고를 외쳐야 한다.

"우리 패 바꾸자!"는 패가 안 좋을 때 역전의 카드다. 물론 상대 패가 더 안 좋으면 역효과지만, 그게 도박의 재미다.

## 코인 이코노미 — 무과금 게임의 경제 설계

아이템은 코인으로 산다. 코인은 어떻게 벌까?

```
코인 획득 경로:

  1. 출석 보상     10코인/일
  2. 데일리 룰렛   기본 3회 + 게임 보상
  3. 슬롯 머신     기본 10회 + 게임 보상 (베팅 5~100코인)
  4. 게임 승리     상대 점수 기반 코인 보상
```

룰렛의 확률표가 재밌다:

| 확률 | 보상 |
|------|------|
| 3% | +100코인 |
| 7% | +50코인 |
| 20% | +10코인 |
| 60% | 꽝 |
| 10% | -10코인 |

**60%가 꽝이고 10%는 마이너스다.** 현실적인 확률이다. 무료 게임이라 과금 요소는 없고, 코인은 게임 내에서만 순환한다. 기획자 입장에서 이런 확률 설계는 익숙하지만, 직접 코드로 구현하니까 `Random().nextInt(100)`의 범위를 세팅하는 그 순간이 묘하게 재밌었다.

슬롯 머신은 좀 더 도박 감성이다. 최소 베팅 5코인, 최대 100코인. 잭팟(0.4%)은 40배, 트리플(2%)은 10배, 더블(18%)은 1.5배. **79.6%는 꽝**이다. 슬롯 머신의 잭팟 배수는 월마다 미세하게 다르다 — 이런 디테일은 AI에게 "슬롯 머신 잭팟에 변화를 주고 싶은데"라고 했더니 알아서 month 기반 variance를 넣어줬다.

## 광끼 게이지 — 게임의 시그니처 시스템

"光끼의 맞고"에서 "光끼"가 뭔지 이야기할 차례다. **광끼 게이지**는 이 게임만의 고유 시스템이다.

```
광끼 게이지 (0~100):

  [████████████████████░░░░░] 80/100

  색상 변화:
    0~40:   노랑 (평온)
    40~70:  주황 (경고)
    70~100: 빨강 (위험)
    100:    불꽃 애니메이션 + 활성화 가능!
```

게이지가 100에 도달하면 캐릭터가 "mad" 표정으로 바뀌고, 불꽃 애니메이션이 재생되며, **광끼 모드**를 발동할 수 있다. 광끼 모드가 발동되면 게임에 특수 효과가 적용된다.

광끼 게이지는 게임이 불리할수록 빠르게 찬다. 역전의 기회를 주는 시스템이다. 아이템 중 "光끼의 물약"은 이 게이지를 즉시 100%로 채워준다 — 50코인이라는 높은 가격은 그만큼의 가치가 있다.

위젯 구현에서 불꽃 애니메이션은 500ms 주기로 0.8~1.2 스케일이 왔다 갔다 하고, 배경 글로우는 1500ms 주기로 투명도가 0.3~1.0으로 변한다. 이런 애니메이션 디테일은 기획서에 "불꽃 효과"라고 한 줄 쓸 걸, 코드로는 `AnimationController` 두 개에 `Tween` 설정이 필요하다.

## 카드 프리로딩 — 브라우저의 동시 요청 제한

Flutter Web에서 게임을 만들면서 만난 의외의 문제가 있다. **브라우저의 동시 이미지 요청 제한**이다.

화투 카드는 48장 + 보너스 피 2장 + 카드 뒷면 = 총 51개 이미지다. 여기에 아바타 15개(3캐릭터 × 5표정)까지 더하면 66개. 이걸 게임 시작할 때 한꺼번에 로드하면 브라우저가 버벅인다.

브라우저는 같은 도메인에 대해 동시 HTTP 요청을 **6개 정도**로 제한한다. 66개 이미지를 한꺼번에 요청하면 11번의 라운드트립이 순차적으로 발생한다.

해결책은 **배치 프리로딩**이다:

```
카드 프리로딩 전략:

  총 51장의 카드 이미지
  → 6장씩 배치로 나누기 (브라우저 동시 요청 제한 고려)
  → Future.wait()로 배치 내 병렬 로드
  → 배치 완료 후 다음 배치 진행
  → 전부 로드 완료 → 게임 시작 가능

  아바타도 별도 프리로더로 동일 패턴 적용
```

게임 화면이 마운트되면 `addPostFrameCallback`에서 아바타와 카드를 동시에 프리로딩한다. 6장씩 끊어서 `Future.wait()`로 병렬 로드하고, 실패한 이미지는 카운트만 해두고 넘어간다. 프리로딩이 끝나면 게임 중에는 모든 카드가 캐시에서 즉시 표시된다.

네이티브 앱이었다면 이런 고민이 필요 없다. 이미지가 앱 번들에 포함되니까. Flutter Web이라서 생기는 문제다. [[맞고 1편 - 기획자가 10일 만에 멀티플레이어 카드게임을 만들다|1편]]에서 "카드 게임은 FPS 60이 필요한 장르가 아니다"라고 했는데, 대신 **이미지 로딩 최적화**가 필요하다.

## Vercel 배포 — Flutter Web을 서버리스로

Flutter Web 앱을 어디에 배포할까? 선택지는 Firebase Hosting, GitHub Pages, Vercel, Netlify 등이 있다. **Vercel**을 선택했다.

이유는:
1. **빌드 캐시** — Flutter SDK를 한 번 클론하면 다음 빌드에서 재사용
2. **프리뷰 배포** — PR마다 프리뷰 URL 생성
3. **글로벌 CDN** — 한국에서도 빠르다
4. **설정 간단** — vercel.json 하나면 끝

문제는 Vercel에 Flutter SDK가 없다는 거다. 빌드할 때마다 Flutter를 설치해야 한다. `vercel.json`의 빌드 커맨드가 이렇다:

```
빌드 흐름:

  1. Flutter SDK가 있나?
     → 있으면: git pull (업데이트만)
     → 없으면: git clone --depth 1 (최소 설치)
  2. Flutter Web 활성화
  3. pub get (패키지 설치)
  4. flutter build web --release
  5. build/web/ 디렉토리를 배포
```

처음 빌드는 Flutter SDK 클론 때문에 시간이 좀 걸리지만, 이후 빌드는 캐시 덕분에 빨라진다. `--depth 1`로 최신 커밋만 클론해서 용량을 줄인 것도 포인트다.

SPA(Single Page Application) 설정도 필요하다. Flutter Web은 클라이언트 사이드 라우팅을 쓰기 때문에, 모든 경로를 `index.html`로 리다이렉트해야 한다. Vercel의 rewrites 설정 한 줄로 해결된다.

추가로 CORS 헤더 설정이 필요했다. Firebase Auth의 Google 로그인이 `window.open()`을 쓰는데, `Cross-Origin-Opener-Policy`를 `same-origin-allow-popups`로 설정하지 않으면 팝업이 차단된다.

## PWA 지원 — 앱처럼 설치하기

Flutter Web은 기본적으로 PWA(Progressive Web App)를 지원한다. `manifest.json`을 설정하면 모바일 브라우저에서 **"홈 화면에 추가"**로 앱처럼 설치할 수 있다.

```
PWA 설정:

  앱 이름:    光끼의 맞고
  표시 모드:   standalone (브라우저 UI 숨김)
  화면 방향:   portrait-primary (세로 고정)
  테마 색상:   #1F581A (짙은 녹색 — 화투 테이블 느낌)
  아이콘:     192px, 512px (일반 + maskable)
```

`standalone` 모드로 설정하면 브라우저의 주소창과 메뉴 바가 사라져서, 마치 네이티브 앱처럼 보인다. 테마 색상은 짙은 녹색인데, 화투 치는 방바닥의 녹색 깔개 느낌을 살렸다.

Maskable 아이콘은 안드로이드의 적응형 아이콘을 위한 건데, 원형으로 잘려도 핵심 그래픽이 보이도록 여백을 둔 버전이다. 디자이너가 이것도 준비해줬다.

## 전체 아키텍처 정리

10일 동안 만든 光끼의 맞고의 최종 아키텍처를 정리하면:

```
┌─────────────────────────────────────────────────┐
│                    Vercel CDN                     │
│              (Flutter Web 정적 호스팅)              │
├─────────────────────────────────────────────────┤
│                                                   │
│  ┌─────────┐    Firebase     ┌─────────┐         │
│  │Player 1 │ ←── Realtime ──→ │Player 2 │         │
│  │         │      DB         │         │         │
│  │ 게임로직  │                 │  리스너  │         │
│  │ (client) │                 │ (client) │         │
│  └─────────┘                 └─────────┘         │
│       │                           │               │
│       └───────┐           ┌───────┘               │
│               ▼           ▼                       │
│        Firebase Auth (Google/익명 로그인)           │
│        Firebase Remote Config (디버그 설정)         │
│                                                   │
├─────────────────────────────────────────────────┤
│  게임 로직    │ matgo_logic_service.dart (3000줄)    │
│  점수 계산    │ score_calculator.dart               │
│  방 관리     │ room_service.dart                   │
│  아이템      │ item_service.dart + item_data.dart   │
│  코인       │ coin_service.dart                    │
│  UI        │ game_screen_new.dart (5000줄)         │
└─────────────────────────────────────────────────┘
```

서버가 없다. Firebase가 인증과 데이터 동기화를 담당하고, Vercel이 정적 파일을 호스팅한다. 게임 로직은 전부 클라이언트. 서버리스 아키텍처의 극단적 사례다.

## 시리즈를 마치며 — 기획서 한 줄이 코드 N줄이 되기까지

맞고 게임을 만들면서 확신한 게 하나 있다. **"기획서 한 줄 = 코드 N줄"의 N은 항상 예상보다 크다.**

| 기획서 표현 | 실제 코드량 |
|------------|-----------|
| "맞고 규칙 구현" | 3000줄 (matgo_logic_service.dart) |
| "게임 화면 개발" | 5000줄 (game_screen_new.dart) |
| "실시간 대전" | Firebase Transaction + fallback 패턴 |
| "아이템 8종" | item_service.dart + item_data.dart + UI |
| "코인 시스템" | coin_service.dart + 룰렛 + 슬롯머신 |
| "Vercel 배포" | Flutter SDK 클론 + SPA 리라이트 + CORS 설정 |

순시미네를 만들 때는 [[앱 개발기 1편 - 기획자가 처음으로 앱을 직접 만들기로 하다|"기획자가 직접 만들 수 있을까?"]]라는 질문으로 시작했다. 백엔드 리팩토링에서는 [[백엔드 도전기 1편 - 기획자가 왜 백엔드를 뜯어고치게 되었나|"기획자가 백엔드를 건드려도 되나?"]]라는 질문이었다. 맞고에서는 **"기획자가 게임을 만들 수 있을까?"**였다.

세 질문의 답은 모두 **"된다, 근데 만만하진 않다"**이다.

순시미네 → 백엔드 리팩토링 → 맞고로 이어지는 여정에서 느낀 건, 바이브 코딩의 가능성이 매번 기대 이상이었다는 거다. Flutter + Supabase로 앱을 만들고, NestJS 백엔드를 리팩토링하고, Flutter Web + Firebase로 실시간 카드 게임까지. 전부 AI와의 대화로 만들었다.

물론 기술 부채는 있다. 228KB짜리 갓 위젯, 클라이언트 사이드에만 있는 게임 로직, 테스트 코드 부재. 다음에 시간이 되면 리팩토링하겠지만... 솔직히 또 새로운 걸 만들고 싶은 마음이 더 크다.

**결국 기획자에게 중요한 건, 코드의 완벽함이 아니라 "만들어서 사람들에게 보여줄 수 있는가"다.** 光끼의 맞고는 URL 하나로 바로 플레이할 수 있다. 그게 10일 스프린트의 가장 큰 성과다.

---

> **이전 편**: [[맞고 2편 - 맞고 규칙을 3000줄의 코드로 번역하다]]
