---
title: "[기획자의 개발 도전기] 7편 - 카카오 알림톡 26개 템플릿을 14개 API에 심다"
date: 2026-02-26
tags:
  - 바이브코딩
  - 카카오알림톡
  - 비즈뿌리오
  - 알림시스템
  - API통합
---

# 카카오 알림톡 26개 템플릿을 14개 API에 심다

## 앱 푸시만으로는 부족하다

[[백엔드 도전기 6편 - Native앱과 WebView 사이에서 FCM 토큰 살리기|앞선 두 편]]에서 FCM 앱 푸시 시스템을 정비했다. 그런데 푸시에는 근본적인 한계가 있다. **앱을 설치하지 않았거나 알림을 꺼놓은 사용자에게는 도달할 수 없다.**

우리 서비스의 핵심 사용자층인 보호자(어르신의 자녀 세대)는 카카오톡을 거의 확인한다. 매칭이 성사되거나, 돌봄 일정이 바뀌거나, 복약 요청이 등록되면 **카카오 알림톡으로 즉시 알려주는 것**이 사용자 경험에 결정적이다.

비즈뿌리오(Bizppurio)라는 카카오 알림톡 발송 대행 서비스를 통해 연동하기로 했다. 비즈뿌리오에 등록한 알림톡 템플릿이 26개. 이걸 우리 API 핸들러 14개 파일에 심어야 했다.

## 아키텍처 — 3계층 구조

발송 흐름을 3계층으로 설계했다.

```
[1] API 핸들러 — 비즈니스 로직 성공 후 알림톡 함수 호출
     ↓
[2] alimtalk.ts — 편의 함수 (템플릿 변수 치환 + 메시지 빌드)
     ↓
[3] bizppurio.ts — 비즈뿌리오 Web API 호출 + DB 로깅
     ↓
[비즈뿌리오 서버] → 카카오 알림톡 발송
```

### 왜 3계층인가

처음에는 API 핸들러에서 직접 비즈뿌리오 API를 호출하려 했다. 그런데 같은 알림톡을 여러 API에서 보내는 경우가 있었다. 예를 들어 매칭종료 알림은 접수/수락/거절/자동종료 4개 API에서 비슷한 템플릿을 쓴다. 직접 호출하면 템플릿 변수 매핑 코드가 4곳에 중복된다.

중간에 `alimtalk.ts`를 두면 `sendGuardianTerminateFiledAlimtalk({ wardName, staffName, ... })` 같은 편의 함수 하나로 호출할 수 있다. 내부에서 템플릿 코드를 찾고, 변수를 치환하고, 비즈뿌리오 API를 호출한다. API 핸들러는 "무슨 알림을 보내라"만 말하면 된다.

## 26개 템플릿의 전체 지도

템플릿을 도메인별로 정리하면 이렇다.

### A. 회원 관련 — 4개

| 템플릿 | 트리거 | 수신자 |
|--------|--------|--------|
| 보호자 회원가입 | `POST /v1/guardian/sign-up` 성공 | 본인 |
| 보호자 회원탈퇴 | `POST /v1/guardian/withdraw` 성공 | 본인 |
| 매니저 회원가입 | `POST /v1/staff/sign-up` 성공 | 본인 |
| 매니저 회원탈퇴 | `POST /v1/staff/withdraw` 성공 | 본인 |

가장 단순한 유형이다. 1명에게 1개의 알림톡을 보내면 끝.

단, 탈퇴 알림에는 함정이 있다. 탈퇴 처리(soft delete)를 하면 `member` 테이블에서 전화번호를 조회할 수 없게 될 수 있다. 그래서 **탈퇴 처리 전에 전화번호를 미리 조회**해두고, 탈퇴 완료 후에 알림톡을 발송한다.

### B. 어르신 프로필 관련 — 3개

| 템플릿 | 트리거 | 수신자 |
|--------|--------|--------|
| 어르신 프로필 추가 | `POST /v2/guardian/wards` 성공 | 본인 |
| 장기요양등급 발급 지원 | 위와 동일 API, 등급 미보유 시 | 본인 |
| 어르신 프로필 공유 수락 | `PUT /v2/matching-share/accept/{token}` 성공 | 공유받은 보호자 |

여기서 재미있는 건 **같은 API에서 조건부로 2개의 알림톡을 보내는 경우**다. 어르신을 등록하면 "프로필 추가" 알림을 보내고, 추가로 장기요양등급이 없으면 "등급 발급 지원" 알림을 한 번 더 보낸다.

```typescript
// 어르신 등록 성공 후
sendGuardianWardAddedAlimtalk({ wardName, phoneNumber, memberId }).catch(...);

// 등급 미보유 시 추가 발송
if (!result.ward.longTermNursingGrade) {
  sendGuardianGradeSupportAlimtalk({ phoneNumber, memberId }).catch(...);
}
```

### C. 복약 도움 관련 — 5개

| 템플릿 | 트리거 | 수신자 |
|--------|--------|--------|
| 보호자 복약 신청 알림 | `POST /v2/medication-request` | 전체보호자 |
| 매니저 복약 신청 알림 | 위와 동일 API | 배정된 매니저 N명 |
| 매니저 복약 변경 알림 | `PUT /v2/medication-request/{id}` | 배정된 매니저 N명 |
| 보호자 복약 종료 알림 | `PUT /v2/medication-request/{id}/end` | 전체보호자 |
| 매니저 복약 종료 알림 | 위와 동일 API | 배정된 매니저 N명 |

여기서 **"전체보호자"**라는 개념이 등장한다. 어르신 한 명에 대표 보호자, 부보호자 등 여러 보호자가 연결될 수 있다. 복약 요청 같은 중요한 알림은 한 명이 아니라 **연결된 모든 보호자**에게 보내야 한다.

이걸 위해 `getAllGuardianPhones()` 헬퍼를 만들었다:

```typescript
export async function getAllGuardianPhones(wardId: bigint) {
  const guardians = await prisma.guardianWard.findMany({
    where: { wardId, isDeleted: false },
    include: {
      guardian: { select: { mobilePhoneNo: true, name: true } },
    },
  });

  return guardians
    .filter((g) => g.guardian?.mobilePhoneNo)
    .map((g) => ({
      memberId: g.memberId,
      phoneNumber: g.guardian!.mobilePhoneNo!,
      name: g.guardian!.name || "",
    }));
}
```

`guardianWard` 테이블에서 해당 어르신과 연결된 모든 보호자를 조회하고, 전화번호가 있는 사람에게만 발송한다. 이 헬퍼 하나가 14개 API 파일 중 8개에서 사용된다.

### D. 매칭종료 — 보호자 발신 8개 + 매니저 발신 4개 = 12개

이게 이번 작업에서 가장 복잡한 부분이었다. 매칭종료는 알림 시나리오가 정말 많다.

**보호자가 종료를 요청한 경우** (8개 템플릿):
- 접수: 전체보호자에게 접수 알림 + 케어매니저에게 접수 알림
- 거절: 전체보호자에게 거절 알림 + 케어매니저에게 거절 알림
- 수락: 전체보호자에게 수락 알림 + 케어매니저에게 수락 알림
- 자동종료(7일): 전체보호자에게 자동종료 알림 + 케어매니저에게 자동종료 알림

**케어매니저가 종료를 요청한 경우** (4개 템플릿):
- 접수: 전체보호자에게 접수 알림
- 거절: 전체보호자에게 거절 알림
- 수락: 전체보호자에게 수락 알림
- 자동종료(7일): 전체보호자에게 자동종료 알림

보호자 발신은 양쪽 모두(보호자+매니저)에게 알림이 가고, 매니저 발신은 보호자에게만 간다. 이 비대칭이 기획적 결정인데, 매니저가 종료를 요청하면 본인은 이미 알고 있으니 별도 알림이 불필요하다는 판단이다.

코드에서는 `requesterType`으로 분기한다:

```typescript
if (mt.requesterType === "GUARDIAN") {
  // 전체보호자 + 케어매니저에게 발송 (2종 템플릿)
} else {
  // 전체보호자에게만 발송 (1종 템플릿)
}
```

이 분기가 접수(`POST`), 응답(`PUT .../respond`), 자동종료(`POST .../auto-complete`) 3개 API에 각각 들어간다.

### E. 관리자 알림 — 2개

| 템플릿 | 트리거 | 수신자 |
|--------|--------|--------|
| 매칭 완료 | `PUT /v2/matching-request/{id}/approve` | 전체보호자 + 케어매니저 |
| 서비스 일정 변경 | `PUT /v2/matching-complete/{id}/schedule` | 전체보호자 + 케어매니저 |

관리자가 매칭을 승인하거나 일정을 변경하면 양쪽 모두에게 알려야 한다. 알림 내용에는 어르신 이름, 매니저 이름, 서비스 시작일, 시간, 요일, 합계시간이 들어간다.

합계시간 계산을 위한 헬퍼도 만들었다:

```typescript
export function calculateTotalMinutes(startTime: string, endTime: string): string {
  const [sh, sm] = startTime.split(":").map(Number);
  const [eh, em] = endTime.split(":").map(Number);
  return String(eh * 60 + em - (sh * 60 + sm));
}
// "09:00", "12:00" → "180"
```

## Fire-and-Forget — 절대 원칙

26개 알림톡 전부에 적용한 원칙이 하나 있다. **알림톡 발송 실패가 API 응답에 영향을 주면 안 된다.**

매칭 승인 API가 성공했는데, 알림톡 서버가 일시적으로 응답이 느려서 500 에러가 나면? 매칭은 분명히 성공했는데 사용자는 에러 메시지를 보게 된다. 이건 말이 안 된다.

그래서 모든 알림톡 호출을 fire-and-forget으로 처리했다:

```typescript
// 비즈니스 로직 성공 후

// 단일 발송: .catch()로 에러를 잡되 무시
sendGuardianSignupAlimtalk({ ... }).catch((err) =>
  console.error("[alimtalk] 발송 실패:", err)
);

// 복수 발송: IIFE 블록으로 감싸서 비동기 처리
(async () => {
  try {
    const guardians = await getAllGuardianPhones(wardId);
    for (const g of guardians) {
      sendXxxAlimtalk({ ... }).catch(() => {});
    }
  } catch (err) {
    console.error("[alimtalk] 발송 실패:", err);
  }
})();

return success(data);  // 알림톡 결과와 무관하게 즉시 응답
```

`return success(data)`가 알림톡 발송 **이전에** 실행된다. 클라이언트는 바로 성공 응답을 받고, 알림톡은 백그라운드에서 날아간다. 발송 실패는 `BizppurioSendLog` 테이블에 기록되어 나중에 추적할 수 있다.

## 최종 매핑 요약

| API 핸들러 | 동시 발송 템플릿 수 | 전체보호자 조회 |
|------------|---------------------|----------------|
| 보호자 회원가입 | 1 | 불필요 |
| 보호자 회원탈퇴 | 1 | 불필요 |
| 매니저 회원가입 | 1 | 불필요 |
| 매니저 회원탈퇴 | 1 | 불필요 |
| 어르신 등록 | 1~2 | 불필요 |
| 어르신 공유 수락 | 1 | 불필요 |
| 복약 요청 생성 | 2 | 필요 |
| 복약 요청 수정 | 1 | 불필요 |
| 복약 요청 종료 | 2 | 필요 |
| 매칭종료 접수 | 2 | 필요 |
| 매칭종료 응답 | 2 | 필요 |
| 매칭종료 자동완료 | 2 per 건 | 필요 |
| 매칭 승인 | 2 | 필요 |
| 서비스 일정 변경 | 2 | 필요 |

14개 API 파일에 26개 템플릿이 매핑되었다. 한 API에서 최대 2개의 템플릿을 동시에 발송하고, 8개 API에서 `getAllGuardianPhones()`를 사용한다.

## 시리즈 2를 마치며

5~7편에 걸쳐 알림 시스템을 만든 과정을 풀어봤다. 정리하면:

1. **5편**: 수신 동의 없이 푸시를 보내던 레거시 수술 — DB 스키마, 인증, 동의 체크, 발송 이력
2. **6편**: Native앱과 WebView 사이의 FCM 토큰 브릿지 — 7단계 등록 흐름
3. **7편**: 카카오 알림톡 26개 템플릿을 14개 API에 통합 — 비즈뿌리오 연동

앱 푸시와 알림톡은 기획서에서는 부속 기능처럼 보인다. "매칭되면 알림 보내기" — 한 줄이면 끝이니까. 근데 실제로는 토큰 관리, 수신 동의, 발송 채널 분기, 실패 처리, 다중 수신자 조회, 템플릿 변수 치환, fire-and-forget 패턴까지 — 하나의 독립된 시스템이다.

이번 작업에서 가장 크게 느낀 건, **알림은 모든 도메인을 관통한다**는 것이다. 회원가입, 어르신 등록, 복약 요청, 매칭 승인, 매칭 종료, 일정 변경 — 서비스의 모든 중요한 이벤트에 알림이 붙는다. 그래서 알림 시스템을 설계하려면 서비스 전체의 흐름을 알아야 한다. 도메인을 10년 넘게 씹어온 기획자가 이걸 만들면, 어디서 어떤 알림이 필요한지 빠뜨리지 않는다.

기획자가 코드를 만진다고 하면 아직도 의아해하는 사람이 많다. 근데 도메인 전문가가 직접 구현까지 하면, 기획과 개발 사이의 간극이 사라진다. 기획서에 적힌 대로 만드는 게 아니라, 기획 의도를 100% 이해한 사람이 코드를 쓰니까. 그게 바이브 코딩이 기획자에게 열어준 가능성이라고 생각한다.

---

> **이전 편**: [[백엔드 도전기 6편 - Native앱과 WebView 사이에서 FCM 토큰 살리기]]
