---
title: "[기획자의 개발 도전기] 맞고 2편 - 맞고 규칙을 3000줄의 코드로 번역하다"
description: "맞고의 쪽, 뻑, 따닥, 폭탄 등 10종 특수 이벤트를 3000줄 코드로 구현한 과정. 기획서 한 줄이 코드 수백 줄이 되는 현실, 게임 규칙 코드화의 실전 경험."
date: 2026-02-19
tags:
  - 바이브코딩
  - Flutter
  - 맞고
  - 게임로직
  - 상태관리
---

# 맞고 규칙을 3000줄의 코드로 번역하다

## 맞고를 아는 것과 구현하는 건 다르다

[[맞고 1편 - 기획자가 10일 만에 멀티플레이어 카드게임을 만들다|이전 편]]에서 맞고 게임을 만들겠다고 결심한 이야기를 했다. 이제 진짜 만들 차례다.

맞고는 한국인이라면 대부분 칠 줄 안다. 같은 월의 카드를 맞춰서 가져오고, 점수를 모아서 "고" 또는 "스톱"을 외치는 게임이다. 간단하다.

**간단하다고 생각했다.**

규칙을 하나하나 코드로 옮기기 시작하니까, 이 게임이 왜 수십 년간 사랑받았는지 알겠더라. 규칙이 단순한 게 아니라, **기본 규칙 위에 예외가 층층이 쌓여있는** 구조였다.

## 50장의 카드, 4가지 타입

먼저 카드 시스템을 정의해야 한다. 화투는 12개월 × 4장 = 48장이 기본이고, 여기에 보너스 피 2장을 더해서 50장이다.

```
카드 타입 (CardType):

  광 (kwang)      — 빛나는 카드, 5장 존재
  열끗 (animal)    — 동물/새 그려진 카드
  띠 (ribbon)     — 글자 띠가 있는 카드
  피 (pi)         — 아무것도 없는 기본 카드
  쌍피 (doublePi) — 피 2장 가치의 특수 피
  보너스피 (bonusPi) — 추가 피 2장
```

각 월마다 어떤 타입의 카드가 들어있는지가 정해져있다. 예를 들어:

| 월 | 카드 1 | 카드 2 | 카드 3 | 카드 4 |
|----|--------|--------|--------|--------|
| 1월 (송학) | 광 | 띠 | 피 | 피 |
| 2월 (매조) | 열끗 | 띠 | 피 | 피 |
| 3월 (벚꽃) | 광 | 띠 | 피 | 피 |
| 8월 (공산) | 광 | 열끗 | 피 | 피 |
| 9월 (국진) | 열끗★ | 띠 | 피 | 피 |
| 12월 (오동) | 광 | 쌍피 | 피 | 피 |

9월 열끗에 ★ 표시를 한 이유는 나중에 나온다. 이 카드 하나 때문에 엄청난 예외 처리가 필요하다.

덱 생성 코드(`deck_generator.dart`)에서 50장을 만들고, 셔플하고, 딜링한다. 맞고(2인)는 각 10장 + 바닥 8장, 고스톱(3인)은 각 7장 + 바닥 6장. 여기까지는 간단하다.

## 턴 흐름 — 2단계 시스템

맞고의 한 턴은 **2단계**로 이루어진다. 이걸 이해하는 데 시간이 좀 걸렸다.

```
[Phase 1] 패에서 카드 내기
  → 바닥에 같은 월 카드가 있나?
  → 0개: 바닥에 놓기
  → 1개: 매칭! 둘 다 가져오기
  → 2개: 어떤 걸 가져올지 선택 (CardSelectionDialog)
  → 3개: 쓸! 3장 다 가져오기 + 상대 피 1장 빼앗기

[Phase 2] 덱에서 카드 뒤집기
  → 같은 매칭 로직 적용
  → 추가 특수 규칙 체크 (뻑, 쪽, 따닥, 싹쓸이 등)
```

Phase 1과 Phase 2를 합쳐서 한 턴이 완성된다. 문제는 두 단계의 **조합**에서 특수 이벤트가 발생한다는 거다.

## 특수 이벤트 — 맞고의 진짜 복잡성

기본 매칭 로직만 있으면 맞고는 단순한 카드 매칭 게임이다. 맞고를 맞고답게 만드는 건 **특수 이벤트**들이다.

| 이벤트 | 조건 | 효과 |
|--------|------|------|
| 쪽 (kiss) | Phase 1에서 매칭 실패, Phase 2에서 뒤집은 카드가 Phase 1 카드와 같은 월 | 둘 다 가져오기 + 상대 피 빼앗기 |
| 뻑 (puk) | Phase 1에서 1개 매칭, Phase 2에서 같은 월 카드 뒤집힘 → 3장이 바닥에 놓임 | 카드 3장이 바닥에 잠김 (뻑 더미) |
| 자뻑 (jaPuk) | 이전에 뻑 쌓인 카드를 내가 가져오는 경우 | 상대 피 2장 빼앗기 |
| 따닥 (ttadak) | Phase 1과 Phase 2에서 각각 다른 바닥 카드와 매칭 (같은 월) | 전부 가져오기 + 상대 피 빼앗기 |
| 싹쓸이 (sweep) | 턴 종료 후 바닥에 카드가 0장 | 상대 피 빼앗기 |
| 쓸 (sulsa) | 바닥에 같은 월 3장 + 내 패에서 1장 | 4장 다 가져오기 + 상대 피 빼앗기 |
| 흔들기 (shake) | 같은 월 3장이 내 패에 있을 때 공개 | 점수 2배 |
| 폭탄 (bomb) | 같은 월 3장이 패에 있고 바닥에 1장 → 4장 전부 캡처 | 가져오기 + 상대 피 빼앗기 + 2배 |
| 총통 (chongtong) | 딜링 직후 같은 월 4장이 전부 패에 | 즉시 승리 (10점) |
| 멍따 (meongTta) | 열끗 7장 이상 획득 | 점수 2배 |

이걸 전부 `matgo_logic_service.dart`에 구현했다. 이 파일 하나가 **123KB, 약 3000줄**이다. 순시미네 전체 서비스 레이어보다 큰 단일 파일이다.

각 특수 이벤트가 **다른 이벤트와 겹칠 수 있다**는 게 진짜 문제다. 예를 들어, 폭탄을 터뜨리면서 동시에 싹쓸이가 될 수 있다. 흔들기 상태에서 뻑이 발생할 수 있다. 이런 조합을 다 처리해야 한다.

## 점수 계산 — 5가지 카테고리

특수 이벤트를 넘기면 점수 계산이 있다. `score_calculator.dart`에 구현했다.

```
점수 카테고리:

[광] 3광 = 3점, 비광 포함 3광 = 2점, 4광 = 4점, 5광 = 15점
[열끗] 5장부터 (장수 - 4)점씩
[띠] 5장부터 (장수 - 4)점씩
[피] 10장부터 (장수 - 9)점씩 (쌍피는 2장 가치)

[특수 조합]
  고도리: 2월+4월+8월 열끗 = 5점
  홍단:   1월+2월+3월 띠 = 3점
  청단:   6월+9월+10월 띠 = 3점
  초단:   4월+5월+7월 띠 = 3점
```

여기서 "고" 선언 시 보너스가 붙는다:

```
고 보너스:
  1고 = +1점
  2고 = +2점
  3고 = x2배
  4고 = x4배
  5고 = x8배
  ...
```

3고부터 2배씩 증가하는 건 코드로 이렇게 표현된다:

```dart
// 3고=2^1=2, 4고=2^2=4, 5고=2^3=8, ...
final multiplier = 1 << (goCount - 2);
```

비트 시프트 한 줄로 지수 증가를 구현한 부분. AI가 짜줬는데, 깔끔하다고 생각했다.

## 9월 열끗 — 하나의 카드가 만든 특별 분기

아까 9월 열끗에 ★ 표시를 했다. 이 카드는 맞고에서 유일하게 **플레이어가 타입을 선택할 수 있는 카드**다. 열끗(동물)으로 쓸 수도 있고, 쌍피로 쓸 수도 있다.

```
9월 열끗 캡처 시:
  → SeptemberAnimalChoiceDialog 표시
  → "열끗으로 사용" / "쌍피로 사용" 선택
  → 선택에 따라 captured_cards에 다른 카테고리로 분류
  → 점수 계산 시 선택된 타입으로 반영
```

이 카드 하나 때문에:
1. `waitingForSeptemberChoice`라는 별도의 게임 상태 플래그가 필요하고
2. 선택 다이얼로그 UI가 필요하고
3. 카드 캡처 로직에 분기가 추가되고
4. 점수 계산에서도 분기가 추가된다

카드 1장이 만드는 코드량이 상당하다. 전통 게임의 예외 규칙이 코드에서 얼마나 비용이 드는지 체감한 부분이다.

## 40개 필드의 GameState

게임의 모든 상태는 `GameState` 클래스에 담긴다. 이 클래스의 필드를 세어보니 **40개가 넘는다.**

```
GameState 주요 필드들:

  // 기본 상태
  currentTurn, roundNumber, isGameOver, winnerId

  // 덱과 바닥
  deck[], floorCards[], pukCards[]

  // 플레이어 1 상태
  player1Hand[], player1Captured{}, player1Score
  player1GoCount, player1ShakeMultiplier, player1BombMultiplier

  // 플레이어 2 상태
  player2Hand[], player2Captured{}, player2Score
  player2GoCount, player2ShakeMultiplier, player2BombMultiplier

  // 대기 상태 플래그들
  waitingForGoStop, waitingForCardSelection
  waitingForSeptemberChoice, waitingForFirstTurn

  // 특수 이벤트 추적
  lastSpecialEvent, sweepCount, pukOwner
  meongTtaTriggered, chongtongWinner

  // 아이템 효과
  activeItems[], gwangkkiState

  // 첫 턴 데이터
  firstTurnData{}
```

턴이 진행될 때마다 이 상태가 통째로 업데이트된다. 맞고의 규칙이 복잡한 만큼 상태도 복잡하다. 이 상태를 Firebase Realtime Database에 실시간으로 동기화해야 하는데, 이건 다음 편에서 이야기하겠다.

## 228KB 위젯 — "갓 위젯"의 탄생

게임 로직이 3000줄이면, 게임 화면은 얼마일까? **5000줄이 넘는다.** `game_screen_new.dart` 파일 하나가 228KB다.

이 파일이 이렇게 커진 이유는, 게임 화면에서 처리해야 할 게 너무 많기 때문이다:

```
game_screen_new.dart가 담당하는 것들:

  1. 3개 영역 레이아웃 (상대방/바닥/내 영역)
  2. 카드 터치 → 내기 → 애니메이션
  3. 10종+ 특수 이벤트 오버레이 표시
  4. 고/스톱 다이얼로그
  5. 카드 선택 다이얼로그 (2개 매칭 시)
  6. 9월 열끗 선택 다이얼로그
  7. 게임 결과 다이얼로그 (상세 점수 분석)
  8. 턴 타이머 (60초)
  9. 효과음 재생 트리거
  10. 광끼 게이지 애니메이션
  11. 아이템 사용 UI
  12. 게임 알림 배너
  13. 재대전 흐름
  14. 코인 정산
```

20개 넘는 boolean 상태 변수가 오버레이를 제어한다: `_showingEvent`, `_showingShakeCards`, `_showingBombCards`, `_showingMeongTtaCards`, `_showingChongtongCards`... 사실상 수동으로 구현한 상태 머신이다.

이건 분명히 **기술 부채**다. 알고 있다. 게임 로직, 애니메이션 제어, UI 렌더링이 하나의 위젯에 다 들어있으면 안 된다. 하지만 10일 스프린트에서 리팩토링할 여유는 없었다. "동작하는 게임"이 "깔끔한 코드"보다 우선이었다. 순시미네에서 싱글톤 서비스를 쓴 것과 같은 이유다 — 지금 내가 이해할 수 있는 구조로 만들고, 나중에 필요하면 리팩토링한다.

## 이번 편을 마치며

맞고 규칙을 코드로 옮기면서 느낀 건, **"규칙을 아는 것"과 "규칙을 구현하는 것"은 완전히 다른 차원의 문제**라는 거다.

맞고를 칠 줄 아는 사람은 수천만 명이다. 하지만 "쪽이 발생하는 정확한 조건이 뭐야?"라고 물으면 대부분 감으로 안다. 감으로 아는 걸 `if-else`로 바꾸려면, 모든 조건을 빠짐없이 명시해야 한다. 이게 3000줄이 되는 거다.

기획서를 쓸 때 "맞고 규칙 구현"이라고 한 줄이면 되는 걸, 코드로는 3000줄에 40개 상태 필드에 10종 특수 이벤트 처리가 된다. [[2편 - 80컬럼짜리 괴물 테이블을 세 조각으로 나누다|80컬럼짜리 괴물 테이블]]을 다룰 때도 느꼈지만, 복잡한 도메인 규칙을 코드로 옮기는 건 항상 예상의 몇 배가 든다.

다음 편에서는 이 복잡한 게임 상태를 **실시간으로 두 사람 사이에 동기화**하는 이야기, 그리고 Flutter Web을 Vercel에 배포하면서 겪은 이슈들을 다루겠다.

---

> **이전 편**: [[맞고 1편 - 기획자가 10일 만에 멀티플레이어 카드게임을 만들다]]
> **다음 편**: [[맞고 3편 - 실시간 대전에서 Vercel 배포까지]]
