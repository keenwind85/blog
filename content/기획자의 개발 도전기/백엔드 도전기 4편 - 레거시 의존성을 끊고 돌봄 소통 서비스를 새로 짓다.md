---
title: "[기획자의 개발 도전기] 4편 - 레거시 의존성을 끊고 돌봄 소통 서비스를 새로 짓다"
date: 2026-01-05
tags:
  - 바이브코딩
  - 리팩토링
  - 돌봄서비스
  - 캘린더
  - 시스템설계
---

# 레거시 의존성을 끊고 돌봄 소통 서비스를 새로 짓다

## 매칭은 바꿨는데, 돌봄이 문제다

2편에서 매칭 테이블을 3개로 나눴다. 그런데 기존 돌봄 관련 기능들이 전부 레거시 `matching` 테이블에 FK로 연결되어 있었다. 매칭 구조를 바꿔놨더니 돌봄 기능이 갈 곳을 잃은 거다.

구체적으로 이런 상황이었다:

| 기존 모델 | 문제 |
|-----------|------|
| `CareLog` (돌봄일지) | `matchingId`로 레거시 `matching` 테이블 참조 |
| `MedicationRequestStaff` (복약 배정) | `matchingId`로 레거시 `matching` 테이블 참조 |
| 캘린더 | 별도 구현 자체가 없음. 레거시 `monthly-schedule` API가 matchingId 기반 |
| 돌봄일지 댓글 | 기능 자체가 존재하지 않음 |

레거시 `matching` 테이블을 당장 DROP할 수 없는 이유가 바로 이것이었다. 돌봄 기능들이 아직 매달려 있으니까.

결국 선택은 두 가지였다. 기존 돌봄 기능의 FK를 `matching_complete`로 변경하는 방법과, 돌봄 서비스 자체를 새로 만드는 방법. 후자를 선택했다. 어차피 기존 돌봄일지는 기능이 부족했고, 캘린더도 댓글도 없었으니까. 제대로 만들 기회였다.

## 새 돌봄 소통 서비스의 구조

설계한 전체 구조는 이렇다:

```
matching_complete (활성 매칭)
    │
    ├── care_journal (돌봄일지)
    │       └── care_journal_comment (댓글)
    │
    ├── medication_request_staff (복약 요청 Staff 배정)
    │       └── medication_request (복약 요청)
    │
    └── care_calendar (Computed Read — 별도 테이블 없음)
            = matching_complete + care_journal + medication_request 조합
```

모든 돌봄 기능이 `matching_complete`(활성 매칭)에 연결된다. 레거시 `matching` 테이블과의 의존성을 완전히 끊은 것이다.

## 복약 요청과 Staff 자동 배정

가장 먼저 구현한 건 복약 도움 요청 기능이다. 보호자가 "우리 어머니 약 좀 챙겨주세요"라고 요청하면, 시스템이 알아서 담당 케어매니저를 배정해야 한다.

문제는 어르신 한 명에 **여러 매칭이 동시에 존재**할 수 있다는 것이다. 월/수/금은 김 매니저, 화/목은 이 매니저가 담당하는 경우가 실제로 있다. 보호자가 "매일 아침 혈압약"을 요청하면 누가 담당하나?

이걸 해결하기 위해 **serviceDays 교차 계산** 알고리즘을 만들었다.

```
어르신 A의 활성 매칭:
  - 김 매니저: 월,수,금 09:00~12:00
  - 이 매니저: 화,목 14:00~18:00

복약 요청: dosageDays = "월,화,수"

→ 교집합 계산:
  김 매니저 (월,수,금) ∩ 복약 (월,화,수) = 월,수 → 김 매니저 배정
  이 매니저 (화,목) ∩ 복약 (월,화,수) = 화 → 이 매니저 배정

→ 결과:
  김 매니저 → assignedDays: "월,수"
  이 매니저 → assignedDays: "화"
```

검증 규칙도 넣었다. 복약 요청의 모든 요일이 활성 매칭의 serviceDays 합집합에 포함되어야 한다. 만약 "토요일"을 넣었는데 토요일에 서비스하는 매니저가 없으면 에러를 반환한다. 기획적으로 당연한 건데 코드로 안 잡아두면 데이터가 꼬인다.

복약 요청을 수정할 때도 이 로직이 다시 돌아간다. dosageDays가 변경되면 Staff 배정을 전부 다시 계산한다.

## 돌봄일지 — 태스크 시스템의 탄생

기존 돌봄일지(`CareLog`)는 단순한 텍스트 기록이었다. 케어매니저가 "오늘 어르신 식사 도움드렸습니다"라고 적으면 끝이었다. 보호자 입장에서는 구체적으로 뭘 했는지 알기 어려웠다.

이걸 **태스크 기반 시스템**으로 바꿨다. 돌봄일지를 생성하면 자동으로 체크리스트가 만들어진다.

```json
[
  { "type": "MEAL", "label": "아침식사", "completedAt": null },
  { "type": "MEAL", "label": "점심식사", "completedAt": null },
  { "type": "MEAL", "label": "저녁식사", "completedAt": null },
  { "type": "MEDICATION", "label": "혈압약", "completedAt": null },
  { "type": "MEDICATION", "label": "당뇨약", "completedAt": null },
  { "type": "EXERCISE", "label": "운동", "completedAt": null }
]
```

식사 3개(아침/점심/저녁)와 운동 1개는 기본으로 들어가고, **복약 태스크는 해당 날짜의 ACTIVE 복약 요청에서 자동으로 가져온다.** 보호자가 "혈압약, 당뇨약" 복약 요청을 해뒀으면, 돌봄일지를 만들 때 자동으로 태스크에 포함된다.

케어매니저가 현장에서 태스크를 완료하면 `completedAt`에 시간이 기록된다. 보호자는 실시간으로 "아, 오늘 아침식사 도움 받았구나, 혈압약도 챙겨드셨네"를 확인할 수 있다.

여기서 한 가지 제약을 뒀다. **태스크 실시간 업데이트는 당일 일지에만 가능하다.** 이틀 전 일지에 "사실 운동도 했어요"라고 추가하는 건 안 된다. 이건 기획적으로 데이터 신뢰성을 위한 결정이었다. 단, 메모(`content`)나 사진은 과거 일지도 수정할 수 있게 열어뒀다.

`tasks` 컬럼을 JSON text로 저장한 것도 의도적인 선택이다. 정규화해서 별도 테이블로 만들 수도 있었지만, 태스크 구조가 아직 확정되지 않은 상태에서 스키마를 고정하면 나중에 유연성이 떨어진다. JSON이면 새 태스크 타입 추가가 자유롭다.

## 댓글 — 보호자와 매니저가 소통하다

기존에 없던 기능 중 하나가 돌봄일지 댓글이다. 보호자가 일지를 보고 "오늘 식사량은 어땠나요?"같은 질문을 남기고, 케어매니저가 답하는 기능이다.

`care_journal_comment` 테이블을 새로 만들었다. 설계에서 신경 쓴 부분들:

**대댓글 1단계**: `parentCommentId`로 셀프 조인을 걸어 대댓글을 지원한다. 하지만 2단계 이상의 중첩은 안 된다. SNS가 아니니까 깊은 스레드는 필요 없다.

**작성자 이름 스냅샷**: `memberName`을 댓글에 직접 저장한다. 2편에서 배운 스냅샷 전략과 같은 원리다. 사용자가 이름을 바꿔도 과거 댓글의 작성자명이 변하지 않는다.

**Soft delete**: 삭제해도 DB에서 지우지 않고 `isDeleted = true`로 표시한다. 대댓글이 달린 댓글을 물리 삭제하면 대댓글이 고아가 되니까.

**commentCount 자동 관리**: 돌봄일지의 `commentCount` 필드가 댓글 작성/삭제 시 자동으로 증감한다. 목록 화면에서 "댓글 3개"를 보여주기 위해 매번 COUNT 쿼리를 날리지 않아도 된다.

## 캘린더 — 테이블 없이 만드는 법

캘린더를 어떻게 구현할지 고민이 많았다. 일반적으로는 캘린더 이벤트 테이블을 만들고 CRUD로 관리하는데, 우리 서비스의 돌봄 스케줄은 **이미 다른 테이블에 정보가 다 있었다.**

- `matching_complete`에 서비스 요일, 시간이 있고
- `care_journal`에 해당 날짜의 일지 작성 여부가 있고
- `medication_request`에 복약 요청 정보가 있다

별도 테이블을 만들면 데이터 동기화 문제가 생긴다. 매칭 일정이 바뀌면 캘린더도 업데이트해야 하고, 복약 요청이 생기면 캘린더에도 반영해야 하고... 이건 버그의 온상이다.

그래서 **Computed Read** 패턴을 선택했다. 캘린더 테이블은 존재하지 않고, 조회 시점에 세 테이블의 데이터를 조합해서 캘린더를 만들어낸다.

```
GET /v2/care-calendar?wardId=123&yearMonth=2025-02

처리 과정:
1. wardId의 활성 matching_complete 전체 조회
2. 2025년 2월의 모든 날짜에 대해 반복:
   a. 해당 날짜의 요일 계산 ("월","화",...)
   b. 각 매칭의 serviceDays에 해당 요일 포함 → 스케줄 존재
   c. care_journal 존재 여부 + 읽음 상태 확인
   d. ACTIVE 복약 요청 중 해당 날짜에 해당하는 것 추출
3. 모든 정보를 날짜별로 조합하여 반환
```

이 방식의 장점은 **항상 최신 상태를 보장**한다는 것이다. 매칭 일정이 바뀌면 다음 조회 시 자동 반영된다. 데이터 동기화 문제가 원천적으로 없다.

단점은 매번 계산한다는 것인데, 현재 데이터 규모에서는 문제가 되지 않는다. 한 어르신의 활성 매칭이 보통 1~3개이고, 한 달 일지도 많아야 20~30개니까.

## Ward 단위 통합 조회

캘린더에서 한 가지 중요한 설계 포인트가 있다. 조회 기준이 매칭이 아니라 **어르신(Ward) 단위**라는 것이다.

어르신 한 명에 여러 매칭이 동시에 있을 수 있다. 보호자는 "우리 어머니 이번 달 돌봄 현황"을 한 화면에서 보고 싶다. 매칭별로 나뉘어 있으면 김 매니저 캘린더, 이 매니저 캘린더를 따로 봐야 한다.

wardId를 기준으로 모든 활성 매칭을 한꺼번에 조회하고, 각 날짜에 어떤 매니저가 어떤 시간에 오는지를 통합해서 보여준다. 공유 보호자(`guardian_ward` 관계로 연결된 부보호자)도 같은 캘린더를 볼 수 있다.

이건 기획자적 관점이 설계에 반영된 대표적인 예시라고 생각한다. 개발자는 데이터 구조에서 출발해서 "매칭 단위가 자연스러운데?"라고 생각할 수 있지만, 사용자 관점에서는 "우리 어머니"가 중심이다.

## 16개 API로 완성된 돌봄 소통 서비스

최종적으로 만들어진 API 목록:

- **복약 도움 요청**: 생성/목록/상세/수정/종료 — 5개
- **돌봄일지**: 생성/목록/상세/수정/태스크업데이트/읽음처리 — 6개
- **돌봄일지 댓글**: 작성/목록/수정/삭제 — 4개
- **캘린더**: 월별 조회 — 1개

총 16개. 이 16개가 레거시 `matching` 테이블 의존성을 완전히 끊고, `matching_complete` 기반으로 돌아가는 새로운 돌봄 소통 서비스다.

## 레거시 정리 로드맵

이제 레거시 `matching` 테이블을 참조하는 건 `care_log`(기존 돌봄일지)와 `product_amount`(서비스 금액) 두 개뿐이다.

| 대상 | 현재 상태 | 정리 시점 |
|------|----------|-----------|
| CareLog 모델 | Prisma schema에 유지 중 | 신규 CareJournal 검증 완료 후 삭제 |
| MedicationRequestStaff.matchingId | nullable로 변경 | 데이터 전환 완료 후 컬럼 삭제 |
| v1/monitoring/* API 4개 | 코드 유지 중 | 프론트엔드 전환 완료 후 삭제 |

한 번에 다 정리하고 싶은 유혹이 있지만, 점진적으로 간다. 신규 서비스가 충분히 검증된 후에 레거시를 걷어내야 안전하다. 1편에서 세운 "신규 기능만 v2" 원칙의 연장선이다.

## 시리즈를 마치며

4편에 걸쳐 내가 수행한 백엔드 리팩토링 과정을 풀어봤다. 정리하면 이런 여정이었다.

1. **80컬럼 매칭 테이블을 3개로 분리** — 생명주기별 테이블 분리, 상태 머신 정의, 스냅샷 전략
2. **회원 프로필 시스템 정리** — 기본/매칭 프로필 분리, hamlet 자동매칭, 검색 개선
3. **돌봄 소통 서비스 신규 구축** — 복약 Staff 자동배정, 태스크 기반 일지, Computed Read 캘린더

만든 API만 해도 58개(매칭 17개 + 회원/프로필 25개 + 돌봄 16개). 레거시 API 15개를 삭제하고, DB 테이블 2개를 새로 만들고, 보조 테이블 4개를 정리했다.

### 기획자가 코드를 만지면서 배운 것들

**도메인 지식이 코드 설계에서 진짜 힘을 발휘한다.** "매칭은 세 단계다", "캘린더는 어르신 중심이다", "복약 요청은 요일별로 매니저가 다를 수 있다" — 이런 도메인 인사이트는 서비스를 10년 운영한 사람에게서 나온다. 코드를 잘 치는 것과 좋은 구조를 설계하는 건 다른 능력이다.

**기획서 한 줄이 코드에서는 수십 줄이 된다.** "일정 중복 체크", "자동 종료", "Staff 자동 배정" — 기획서에서는 각각 한 줄이다. 코드로 구현하면 요일 파싱, 시간 비교, 교집합 계산, 트랜잭션 처리, 에러 핸들링이 따라온다. 이 경험 덕분에 기획서를 쓸 때 훨씬 구체적으로 쓰게 됐다.

**점진적 전환이 답이다.** 전체를 한 번에 갈아엎겠다는 유혹은 항상 있다. 하지만 v1과 v2가 공존하면서 검증된 부분부터 교체하는 게 훨씬 안전하다. 특히 소규모 팀에서는.

**바이브 코딩은 도구이고, 판단은 사람이 한다.** AI가 코드를 많이 도와주지만, "이 테이블을 3개로 나눌 거야", "캘린더는 Computed Read로 할 거야" 같은 아키텍처 결정은 결국 도메인을 이해한 사람이 내린다. AI는 구현을 돕지만, 무엇을 만들지는 사람이 정한다.

10년 넘게 기획서를 쓰던 사람이 직접 백엔드를 리팩토링할 줄은 나도 몰랐다. 근데 해보니까 됐다. 완벽하진 않겠지만, 적어도 도메인을 모르는 외주사가 만든 80컬럼 테이블보다는 낫다고 자신한다.

---

> **이전 편**: [[백엔드 도전기 3편 - 흩어진 회원 프로필을 정리하고 검색을 개선하다]]
