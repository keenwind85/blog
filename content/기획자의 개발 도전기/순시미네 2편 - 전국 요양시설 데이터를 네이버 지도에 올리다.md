---
title: "[기획자의 개발 도전기] 순시미네 2편 - 전국 요양시설 데이터를 네이버 지도에 올리다"
date: 2025-09-20
tags:
  - 바이브코딩
  - Flutter
  - Supabase
  - PostGIS
  - 네이버지도
---

# 전국 요양시설 데이터를 네이버 지도에 올리다

## 핵심은 "지도였다

[[순시미네 1편 - 기획자가 처음으로 앱을 직접 만들기로 하다|이전 편]]에서 순시미네 프로젝트를 시작한 이야기를 했다. 이제 본격적으로 앱의 핵심 기능을 만들 차례다.

순시미네 앱의 정체성은 간단하다. **"내 주변 요양시설을 지도에서 찾는다."** 이게 안 되면 앱의 존재 이유가 없다.

하지만 "지도에 마커를 찍는다"는 한 문장이 실제로는 이렇게 분해된다:

```
1. 전국 요양시설 데이터를 어디서 구하나?
2. 데이터를 DB에 어떻게 넣나?
3. "내 위치 반경 5km" 검색을 어떻게 하나?
4. 수만 개 마커를 지도에 어떻게 표시하나?
5. 마커를 탭하면 상세 정보를 어떻게 보여주나?
```

1번부터 5번까지, 하나도 쉬운 게 없었다.

## 공공데이터의 세계

전국 요양시설 정보는 **국민건강보험공단**과 **보건복지부**에서 공공데이터로 제공한다. 노인장기요양보험 홈페이지에서 요양원, 주야간보호, 방문요양 등 시설 정보를 받을 수 있었다.

데이터를 처음 열어보고 놀랐다. 시설 하나에 담긴 정보가 이 정도였다:

| 카테고리 | 포함 항목 |
|---------|---------|
| 기본 정보 | 시설명, 주소, 시설유형, 설립일, 운영상태 |
| 인력 현황 | 시설장, 간호사, 요양보호사1급, 사회복지사, 의사... |
| 시설 현황 | 1인실~4인실, 의료실, 목욕실, 프로그램실... |
| 입소 현황 | 정원, 현원(남/여), 대기자(남/여) |
| 평가 정보 | 종합등급, 점수, 과거 평가이력 |
| 부가 정보 | 홈페이지, 교통편, 주차 정보 |

DB 테이블 하나에 컬럼이 수십 개다. 기존 회사 프로젝트에서 겪었던 "80컬럼짜리 괴물 테이블"이 여기서도 재현됐다. 다만 이번엔 내가 만든 게 아니라 공공데이터가 원래 그런 구조였다.

데이터 가공 과정은 이랬다:

```
공공데이터 CSV/API 다운로드
  → 주소를 좌표(위도, 경도)로 변환 (지오코딩)
  → Supabase PostgreSQL에 테이블 생성
  → 좌표를 PostGIS geography 타입으로 저장
  → 인덱스 생성
```

지오코딩이 은근히 까다로웠다. 공공데이터의 주소가 "서울특별시 강남구 역삼동 123-45" 같은 지번 주소인 경우가 많은데, 이걸 좌표로 바꾸려면 네이버 또는 카카오 지오코딩 API를 써야 했다. 수만 건을 돌리면 API 호출 횟수 제한에 걸리기도 했다.

## PostGIS — SQL로 위치를 다루다

Supabase를 선택한 가장 큰 이유가 여기서 빛났다. PostgreSQL에 PostGIS 확장을 켜면, **SQL 한 줄로 반경 검색**이 된다.

```sql
-- 내 위치에서 반경 5km 안의 시설 조회
SELECT *
FROM facilities_ssmn_basic_full
WHERE ST_DWithin(
  geom,
  ST_Point(127.0276, 37.4979)::geography,
  5000  -- 미터 단위
)
ORDER BY ST_Distance(geom, ST_Point(127.0276, 37.4979)::geography);
```

이걸 Firestore로 하려면 GeoHash 문자열을 생성하고, 범위 쿼리를 조합하고, 정확한 거리 필터링은 클라이언트에서 다시 해야 한다. PostGIS는 이 모든 게 서버 한 방이다.

실제로 Supabase에서 RPC 함수로 감싸서 Flutter에서 호출했다:

```
Flutter 앱에서의 호출 흐름:
  → 현재 위치 획득 (LocationService)
  → supabase.rpc('get_facilities_ssmn_within_radius', params: {
      lat: 37.4979,
      lng: 127.0276,
      radius_meters: 5000
    })
  → 결과를 Facility 모델로 변환
  → 네이버 지도에 마커로 표시
```

RPC 함수를 쓴 이유는, 복잡한 PostGIS 쿼리를 서버 사이드에서 캡슐화하기 위해서다. Flutter 코드에서는 좌표와 반경만 넘기면 된다. SQL을 직접 클라이언트에 노출하지 않으니 보안적으로도 낫다.

## 마커가 너무 많다 — 클러스터링

처음에는 검색된 시설을 전부 개별 마커로 찍었다. 내 주변 5km면 몇십 개 나오니까 괜찮았다. 그런데 사용자가 **지도를 축소**하면 문제가 생겼다.

서울 전체를 보는 줌 레벨에서는 마커가 수백 개가 겹친다. 전국 보기로 가면 수만 개다. 앱이 버벅거리고 마커끼리 겹쳐서 뭐가 뭔지 안 보인다.

해결책은 **클러스터링**이었다. 줌 레벨에 따라 마커를 묶어서 표시하는 방식이다.

```
줌 레벨별 클러스터링 전략:

[전국 보기] 시도(sido) 단위 클러스터
  "서울특별시 (423개)"
  "경기도 (1,280개)"
  ...
    ↓ 확대

[시도 보기] 시군구(sigungu) 단위 클러스터
  "강남구 (45개)"
  "서초구 (38개)"
  ...
    ↓ 확대

[시군구 보기] 법정동(bdong) 단위 클러스터
  "역삼동 (12개)"
  "삼성동 (8개)"
  ...
    ↓ 확대

[동네 보기] 개별 마커
  📍 ○○요양원
  📍 △△주야간보호센터
  ...
```

이 3단계 클러스터링을 PostGIS로 구현했다. 시설의 주소에서 시도, 시군구, 법정동 코드를 추출하고, 각 레벨에서 개수를 집계해서 클러스터 마커를 찍는다. Supabase RPC 함수를 줌 레벨별로 3개(`get_facility_clusters`, `get_sigungu_clusters`, `get_bdong_clusters`) 만들었다.

Flutter 쪽에서는 네이버 지도의 카메라 이동 이벤트를 감지해서, 현재 줌 레벨에 맞는 RPC 함수를 호출한다. 줌 인하면 클러스터가 풀리면서 개별 마커가 나타나고, 줌 아웃하면 다시 묶이는 느낌이다.

기획자로서는 "줌 했을 때 묶어서 보여주세요"라고 한 줄이면 되는 기능이 PostgreSQL 함수 3개 + Flutter 줌 레벨 감지 로직 + 마커 렌더링 분기로 풀어진다. 이런 경험이 계속 쌓이면서, "기획서의 한 줄이 코드에서는 얼마나 되는지"를 체감하게 됐다.

## 시설 상세 화면 — 정보의 바다를 정리하다

마커를 탭하면 `FacilityDetailScreen`이 열린다. 여기서 보여줘야 할 정보가 어마어마했다.

```
┌─────────────────────────────────────┐
│  ○○요양원                    ★ 즐겨찾기 │
│  종합등급: A등급 (92.3점)              │
├─────────────────────────────────────┤
│  📍 서울시 강남구 역삼동 123-45         │
│  📞 02-1234-5678                    │
│  🌐 www.example.com                 │
├─────────────────────────────────────┤
│  [기본정보] [인력현황] [시설현황] [비급여] │
│                                     │
│  정원: 100명                         │
│  현원: 남 42명 / 여 53명              │
│  대기: 남 3명 / 여 5명                │
│                                     │
│  간호사: 5명                         │
│  요양보호사: 32명                     │
│  사회복지사: 3명                      │
│  ...                                │
├─────────────────────────────────────┤
│  [💰 비용 계산기]  [🤖 AI 분석]        │
│  [📞 전화하기]    [📤 공유하기]        │
└─────────────────────────────────────┘
```

데이터가 많으니까 탭으로 나눠서 보여주기로 했다. 기본정보, 인력현황, 시설현황, 비급여 항목, 프로그램, 연계기관까지. 각 탭의 데이터는 Supabase의 서로 다른 테이블에서 가져온다.

| 탭 | 데이터 소스 |
|----|-----------|
| 기본정보 | facilities_ssmn_basic_full |
| 인력현황 | 같은 테이블 (인력 관련 컬럼) |
| 시설현황 | 같은 테이블 (시설 관련 컬럼) |
| 비급여 항목 | facilities_ssmn_etc_nonbenefit |
| 프로그램 | facilities_ssmn_etc_program |
| 연계기관 | facilities_ssmn_etc_partner |
| 장비 현황 | facilities_ssmn_etc_equipment |

여기서 재미있었던 건 **비급여 항목**이다. 요양시설에서 건강보험으로 안 되는 항목들(이미용, 간식, 특별 프로그램 등)의 비용인데, 시설마다 천차만별이다. 이걸 테이블로 깔끔하게 보여주니까 시설 비교가 한눈에 됐다.

비용 계산기(`FeeCalculatorScreen`)도 넣었다. 요양등급과 이용 형태에 따라 본인 부담금이 달라지는데, 이걸 시뮬레이션할 수 있게 했다. 기획자 시절에 "사용자가 비교할 수 있게 해주세요"라고만 쓰던 걸, 직접 화면으로 만들어보니 "비교"라는 게 결국 **정보를 어떻게 정렬하고 강조하느냐**의 문제라는 걸 알겠더라.

## 행정동 코드라는 복병

시설 데이터를 다루면서 예상치 못한 복병을 만났다. **행정동 코드 매핑** 문제다.

공공데이터의 시설 주소는 법정동 기반인데, 실제 행정 구역은 행정동이다. 같은 "역삼동"이라도 법정동 코드와 행정동 코드가 다를 수 있다. 클러스터링할 때 이 코드를 기준으로 묶어야 하는데, 코드 체계가 일치하지 않으면 엉뚱한 곳에 클러스터가 생긴다.

그래서 `bdong_code_mapping` 테이블을 별도로 만들어 법정동-행정동 매핑을 관리했다. 이런 건 기획서에 절대 안 나오는 내용이다. "지도에 시설 보여주세요"라는 한 줄 뒤에 이런 행정 코드 체계가 숨어있을 줄은 몰랐다.

## 이번 편을 마치며

공공데이터를 가져와서 PostGIS로 저장하고, 네이버 지도에 클러스터링으로 표시하고, 상세 화면에서 탭별로 정보를 보여주는 것. 이게 순시미네 앱의 뼈대다.

이 과정에서 가장 크게 느낀 건, **데이터 구조가 곧 서비스 품질**이라는 거다. 공공데이터가 잘 정리되어 있었기 때문에 시설 비교가 가능했고, PostGIS가 있었기 때문에 위치 검색이 빨랐다. 기획자 시절에는 "데이터가 있으니까 보여주면 되지"라고 생각했는데, 실제로는 데이터를 어떻게 저장하고 어떻게 조회하느냐가 핵심이었다.

다음 편에서는 이 지도 앱에 **AI 추천 기능과 커뮤니티**를 붙여 서비스를 완성해가는 이야기를 하겠다.

---

> **이전 편**: [[순시미네 1편 - 기획자가 처음으로 앱을 직접 만들기로 하다]]
> **다음 편**: [[순시미네 3편 - AI 추천부터 커뮤니티까지, 서비스에 살을 붙이다]]
