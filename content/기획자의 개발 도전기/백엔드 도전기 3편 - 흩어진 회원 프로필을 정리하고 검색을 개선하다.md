---
title: "[기획자의 개발 도전기] 3편 - 흩어진 회원 프로필을 정리하고 검색을 개선하다"
description: "흩어진 회원 프로필을 기본·매칭 프로필로 분리하고 검색 API를 개선한 과정. hamlet 자동매칭과 어르신 CRUD 재설계 등 25개 API로 회원 시스템을 정리하다."
date: 2026-01-05
tags:
  - 바이브코딩
  - 리팩토링
  - 회원시스템
  - 프로필
  - API설계
---

# 흩어진 회원 프로필을 정리하고 검색을 개선하다

## 프로필이 어디에 있는 거야

매칭 테이블을 3개로 나누고 나니 자신감이 좀 붙었다. 다음 타깃은 회원 시스템이었다. 그런데 코드를 들여다볼수록 또 한숨이 나왔다.

우리 서비스에는 두 종류의 사용자가 있다. **보호자**(Guardian)와 **케어매니저**(Staff). 그런데 이 두 역할의 프로필 정보가 여기저기 흩어져 있었다.

케어매니저의 경우를 보자:

- `member` 테이블: 이름, 연락처, 생년월일 같은 기본 정보
- `staff` 테이블: 자격증, 경력 같은 직업 정보
- 그런데 서비스 가능 지역, 희망 요일, 돌봄 가능 조건 같은 **매칭에 노출되는 프로필 정보**는? → 어디에도 체계적으로 관리되지 않고 있었다

보호자 쪽도 마찬가지였다. 어르신(Ward) 정보를 관리하는 API가 있긴 했는데, 기존 구조에서는 보호자 기준의 CRUD가 아니라 어르신 단위로만 접근할 수 있어서 "내가 등록한 어르신 목록"을 가져오려면 우회를 해야 했다.

## 핵심 결정: 프로필을 분리한다

케어매니저의 프로필을 두 층으로 나누기로 했다.

**기본 프로필** — member + staff 테이블에 이미 있는 개인 정보
- 이름, 연락처, 자격증, 경력
- 본인만 조회/수정 가능

**매칭 프로필** — 신규 `staff_profile` 테이블
- 서비스 가능 지역(시/도, 시/군/구, 행정동)
- 서비스 가능 요일, 시간대
- 즉시 시작 가능 여부, 날짜 협의 가능 여부
- 동거인 유형, 주요 질환 등 돌봄 가능 조건
- 성격, 관심사

왜 분리했냐면, **매칭 프로필이 없는 케어매니저는 검색에 노출되지 않아야 하기 때문**이다. 기존에는 이 구분이 없어서 프로필을 제대로 채우지 않은 케어매니저도 검색 결과에 나왔다. 보호자 입장에서는 정보가 비어있는 매니저가 뜨는 게 신뢰를 떨어뜨린다.

`staff_profile` 테이블의 `isMatchingVisible` 플래그로 검색 노출을 제어하도록 설계했다. 매칭 프로필 자체가 없으면 검색에 안 나오고, 있더라도 본인이 노출을 끌 수 있다.

## hamlet 자동매칭 — 주소 입력의 고통을 덜다

프로필에서 가장 까다로운 부분은 **주소 처리**였다. 어르신 등록이나 케어매니저 매칭 프로필에서 서비스 지역을 입력하는데, 단순히 "서울시 강남구"까지만 저장하면 매칭 시 세부 지역으로 필터링을 할 수가 없다.

우리는 `hamlet`이라는 테이블을 갖고 있었다. 법정동코드를 기반으로 시/도, 시/군/구, 행정동, 햄릿코드, 햄릿명을 매핑하는 테이블인데, 기존에는 제대로 활용이 안 되고 있었다.

이걸 자동화했다:

```
Daum Postcode API에서 주소 선택
  → bcode(법정동코드) "1168010800" 추출
    → hamlet 테이블 조회
      → serviceSido: "서울특별시"
      → serviceSigungu: "강남구"
      → serviceDong: "역삼동"
      → serviceHamletCode: "..."
      → serviceHamletName: "..."
    → 자동 설정 완료
```

사용자는 주소만 검색하면 되고, 나머지는 시스템이 알아서 채운다. 이건 어르신 등록(`POST /v2/guardian/wards`)과 매칭 프로필 등록(`POST /v2/staff/matching-profile`) 양쪽 모두에 적용했다.

## 어르신 CRUD를 보호자 기준으로 재설계

기존에는 어르신 정보를 다루는 API가 제대로 정리되어 있지 않았다. 보호자-어르신 관계(`guardian_ward` 테이블)는 1:N이라 보호자 한 명이 여러 어르신을 등록할 수 있는데, 이걸 반영한 깔끔한 CRUD가 없었다.

4개 API로 깔끔하게 정리했다:

| API | 설명 | 핵심 로직 |
|-----|------|-----------|
| `POST /v2/guardian/wards` | 어르신 등록 | hamlet 자동매칭 + guardian_ward 관계 생성 |
| `GET /v2/guardian/wards` | 어르신 목록 | 보호자 ID 기준 전체 조회 |
| `PUT /v2/guardian/wards/{wardId}` | 어르신 수정 | 주소 변경 시 hamlet 재매칭 |
| `DELETE /v2/guardian/wards/{wardId}` | 어르신 삭제 | 활성 매칭 존재 시 삭제 차단 |

여기서 비즈니스 룰이 몇 가지 있다:

1. **대표 어르신 자동 관리**: `isSelectedWard = true`로 설정하면 기존 대표 어르신은 자동으로 해제된다. 대표 어르신은 항상 한 명만.
2. **삭제 전 활성 매칭 체크**: 어르신에게 진행 중인 매칭이 있으면 삭제할 수 없다. `matching_complete` 테이블에서 해당 wardId로 조회해서 확인한다.
3. **주소 변경 시 hamlet 재매칭**: 어르신 주소가 바뀌면 hamlet 정보도 자동으로 다시 계산된다.

이런 룰들은 기획할 때 "당연히 이렇게 되어야지"라고 생각했던 것들인데, 기존 시스템에서는 구현이 안 되어 있거나 부분적으로만 되어 있었다. 직접 코드를 짜니까 하나도 빠뜨리지 않고 넣을 수 있었다.

## 검색 API 개선

케어매니저 검색은 보호자가 우리 서비스에서 가장 많이 쓰는 기능이다. 기존 검색 API는 `member`와 `staff` 테이블만 조인해서 결과를 내놨는데, 신규 `staff_profile` 데이터를 통합해야 했다.

`GET /v2/staff/search` API를 개선하면서 이런 변화를 줬다:

- **매칭 프로필이 있는 매니저만 노출**: `staff_profile`이 존재하고 `isMatchingVisible = true`인 경우만
- **서비스 지역으로 필터링**: 보호자가 "강남구 역삼동"으로 검색하면 해당 지역을 커버하는 매니저만 나온다
- **가능 요일/시간대 필터링**: "월,수,금 오전"으로 검색하면 해당 조건에 맞는 매니저를 보여준다
- **상세 조회에 프로필 통합**: `GET /v2/staff/{memberId}`에서 기본 정보 + 매칭 프로필을 한 번에 반환

추천 매니저 API(`GET /v2/staff/search/recommended`)도 같은 구조로 개선했다.

## 두 가지 응답 형식이 공존하는 현실

작업하면서 좀 불편했던 부분이 있다. API 응답 형식이 두 가지가 섞여 있다는 것이다.

```typescript
// v1 레거시 형식
{ responseCode: "0000", responseMessage: "", result: { ... } }

// v2 신규 형식 (일부)
{ code: "0000", message: "성공", data: { ... } }
```

처음에는 v2 API를 전부 새 형식으로 통일하려고 했는데, 이미 프론트엔드에서 레거시 형식에 맞춰 파싱하는 코드가 곳곳에 있었다. 응답 형식을 바꾸면 프론트도 전부 수정해야 한다. 4인 이하 소규모 팀에서 백엔드와 프론트를 동시에 건드리는 건 리스크가 너무 크다.

결국 **프론트엔드 호환성 우선** 원칙을 적용했다. 대부분의 v2 API는 레거시 형식(`responseCode/responseMessage/result`)을 유지하고, 회원가입과 탈퇴 같은 신규 플로우에서만 새 형식을 쓰기로 했다. 깔끔하진 않지만 현실적인 선택이었다.

## 총 25개 API, 정리 완료

회원/프로필 영역에서 정리한 API를 총정리하면:

- **회원 CRUD**: 보호자 4개 + 케어매니저 4개 + 공통 4개 = 12개
- **어르신 CRUD**: 등록/목록/수정/삭제 = 4개
- **케어매니저 프로필**: 기본 프로필 3개 + 매칭 프로필 4개 + 검색/상세 2개 = 9개

이 25개 API가 회원과 프로필이라는 기초 도메인을 단단하게 잡아준다. 매칭 시스템(2편)이 이 기초 위에서 돌아가고, 다음에 다룰 돌봄 소통 서비스(4편)도 이 기초에 의존한다.

## 기획자로서 느낀 점

프로필을 분리하고 검색을 개선하는 작업은 매칭 테이블 해체보다 덜 드라마틱하지만, 실제로는 더 중요한 작업이었을 수 있다. 사용자가 매일 마주치는 건 검색 결과와 프로필 화면이니까.

기획자 시절에는 "프로필 필드 추가해주세요"라고 요청하면 끝이었다. 그런데 직접 해보니 필드 하나를 추가하려면 DB 스키마, API 요청/응답, 프론트 연동, 검색 로직, 기존 데이터 호환성까지 전부 고려해야 한다. 기획서에 적힌 한 줄이 코드에서는 여러 파일에 걸친 변경이 되는 거다.

이 경험 덕분에 기획서를 쓸 때도 달라졌다. "프로필에 성격 필드 추가"가 아니라 "staff_profile 테이블에 personality VARCHAR(500) 추가, 콤마 구분 다중값, 검색 필터에 반영, 매칭 프로필 등록/수정 API에 포함"이라고 쓰게 됐다.

다음 편에서는 이 모든 기반 위에 돌봄 소통 서비스를 새로 만든 이야기를 해보겠다.

---

> **이전 편**: [[백엔드 도전기 2편 - 80컬럼짜리 괴물 테이블을 세 조각으로 나누다]]
> **다음 편**: [[백엔드 도전기 4편 - 레거시 의존성을 끊고 돌봄 소통 서비스를 새로 짓다]]
