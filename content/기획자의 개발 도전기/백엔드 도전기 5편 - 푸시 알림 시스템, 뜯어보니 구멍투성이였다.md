---
title: "[기획자의 개발 도전기] 5편 - 푸시 알림 시스템, 뜯어보니 구멍투성이였다"
description: "수신 동의 없이 푸시를 보내던 레거시 알림 시스템을 해부한 이야기. FCM 토큰 소유자 관리, 수신 동의 체크, 발송 이력 기록까지 4가지 수술로 정비하다."
date: 2026-01-30
tags:
  - 바이브코딩
  - 푸시알림
  - FCM
  - 리팩토링
  - 백엔드
---

# 푸시 알림 시스템, 뜯어보니 구멍투성이였다

## 매칭과 돌봄, 그 다음은 알림이었다

[[백엔드 도전기 4편 - 레거시 의존성을 끊고 돌봄 소통 서비스를 새로 짓다|이전 시리즈]]에서 매칭 시스템과 돌봄 서비스를 리팩토링한 이야기를 했다. 구조를 바꾸고, API를 새로 만들고, 레거시를 정리했다. 그런데 시스템이 아무리 잘 돌아가도 사용자에게 **알려주지 않으면** 의미가 없다.

매칭이 성사되면 보호자에게 알려야 하고, 돌봄일지가 올라오면 확인하라고 푸시를 보내야 하고, 복약 요청이 들어오면 케어매니저가 알아야 한다. 알림은 우리 서비스의 핵심 동맥이었다.

그래서 기존 푸시 알림 시스템을 들여다봤다. 그리고 충격을 받았다.

## 수신 동의 없이 푸시를 보내고 있었다

코드를 열어보니 `sendNotificationToMember()`라는 함수가 있었다. 이름은 그럴듯한데 안을 보니 이랬다:

```typescript
// 기존 코드
export async function sendNotificationToMember(memberId, notification) {
  await prisma.appNotification.create({ ... }); // 알림함에 저장
  await sendPushToMember(memberId, notification); // 바로 FCM 발송
}
```

**수신 동의 체크가 없다.** `member` 테이블에 `serviceAgreeAppPush`, `marketingAgreeAppPush` 같은 동의 컬럼이 버젓이 있는데, 아무도 확인하지 않고 푸시를 쏘고 있었다. 사용자가 "알림 수신 거부"를 했어도 푸시가 오는 구조였다.

기획자 시절이었다면 "알림 수신 동의 체크가 안 되어 있네요, 수정해주세요"라고 이슈를 남기고 끝냈을 거다. 근데 지금은 내가 직접 고쳐야 한다.

## 토큰 테이블에 주인이 없다

더 깊이 들여다보니 문제가 또 있었다. FCM 토큰을 저장하는 `app_token` 테이블을 보자.

| 문제 | 설명 |
|------|------|
| `memberType` 컬럼 없음 | 이 토큰이 보호자 건지 매니저 건지 구분 불가 |
| 토큰 갱신 시 소유자 미갱신 | `PATCH /v1/fcm/{deviceId}/token`에서 `fcmToken`만 업데이트, `memberId`는 안 건드림 |
| 발송 이력 없음 | 누구에게 뭘 보냈는지 추적이 안 됨 |

레거시 데이터를 까보니 상황이 더 재미있었다:

```
soomseeme (보호자 구 앱): 818개 활성 토큰, 808명
soonseeme_manager (매니저 구 앱): 944개 활성 토큰, 940명
```

예전에는 보호자 앱과 매니저 앱이 **별개 앱**이었다. 그래서 같은 기기에 두 개의 토큰 레코드가 존재했다. 그런데 리뉴얼하면서 앱을 하나로 합쳤는데, 토큰 관리 로직은 안 바뀐 거다.

## 해결: 네 가지 수술

### 수술 1 — DB 스키마에 memberType 추가

```sql
ALTER TABLE app_token ADD COLUMN member_type VARCHAR(20) DEFAULT NULL;

-- 레거시 데이터 마이그레이션
UPDATE app_token SET member_type = 'GUARDIAN' WHERE request_type = 'soomseeme';
UPDATE app_token SET member_type = 'STAFF' WHERE request_type = 'soonseeme_manager';
```

간단한 ALTER TABLE이지만, 이 한 줄로 "이 토큰이 누구 건지" 드디어 알 수 있게 됐다.

### 수술 2 — 토큰 갱신 API에 인증 추가

기존 `PATCH /v1/fcm/{deviceId}/token`은 `fcmToken`만 받았다. 누가 요청했는지 모르는 상태에서 토큰만 갈아끼우는 거였다.

이걸 **인증 필수**로 변경했다. 로그인한 사용자가 토큰 갱신을 요청하면, JWT에서 `memberId`와 `memberType`을 추출해서 함께 저장한다.

```typescript
const { fcmToken } = body;
const auth = getAuthHeaders(request); // JWT에서 memberId, memberType 추출

await prisma.appToken.updateMany({
  where: { deviceId },
  data: {
    fcmToken,
    memberId: auth.memberId,
    memberType: auth.memberType,  // "GUARDIAN" | "STAFF"
    isFcmTokenActive: true,
  },
});
```

핵심 원칙: **1 device = 1 active token**. 같은 기기에서 보호자로 로그인했다가 매니저로 전환하면, `memberId`와 `memberType`이 최신 로그인 기준으로 덮어써진다. 예전처럼 같은 기기에 레코드가 2개 생기지 않는다.

### 수술 3 — 수신 동의 체크 로직 삽입

이게 이번 작업의 핵심이다. `sendNotificationToMember()` 함수를 이렇게 바꿨다:

```typescript
export async function sendNotificationToMember(
  memberId: bigint,
  notification: {
    pushType: string;
    notificationType: "SERVICE" | "MARKETING"; // 추가
    title: string;
    body: string;
  },
) {
  // 1. 수신 동의 확인
  const member = await prisma.member.findUnique({
    where: { memberId },
    select: { serviceAgreeAppPush: true, marketingAgreeAppPush: true },
  });

  const isServicePush = notification.notificationType === "SERVICE";
  const agreed = isServicePush
    ? member?.serviceAgreeAppPush
    : member?.marketingAgreeAppPush;

  // 2. 앱 알림함에는 항상 저장 (수신 거부여도 내역은 확인 가능)
  await prisma.appNotification.create({
    data: {
      memberId,
      notificationType: notification.notificationType,
      title: notification.title,
      body: notification.body,
      isRead: false,
    },
  });

  // 3. 수신 동의한 경우만 실제 FCM 발송
  if (agreed) {
    await sendPushToMember(memberId, notification);
  }
}
```

여기서 설계 결정이 하나 있다. **수신 거부한 사용자도 앱 내 알림함에서는 내역을 볼 수 있게** 했다. 푸시(폰에 뜨는 알림)만 안 보내는 거지, 앱을 열어서 직접 확인하는 건 막지 않는다. 이건 기획적 판단인데, 사용자가 "아 내가 거절해서 안 온 거구나"를 인지할 수 있어야 한다고 생각했다.

### 수술 4 — 발송 이력 기록

기존에는 푸시를 보내고 성공/실패를 추적하지 않았다. "어제 푸시 다 갔나요?"라는 질문에 답할 수 없는 구조였다.

`sendPushToMember()` 안에 `AppPushSendHistory` 기록을 추가했다:

```typescript
await prisma.appPushSendHistory.create({
  data: {
    memberId,
    pushType: notification.pushType || "GENERAL",
    title: notification.title,
    body: notification.body,
    sendStatus: result.success ? "SUCCESS" : "FAILED",
    errorMessage: result.errors?.map(e => e.error).join("; ") || null,
  },
});
```

이제 운영 중에 "매칭 완료 푸시가 A 보호자에게 갔는지"를 DB에서 바로 확인할 수 있다.

## 기존에 잘 동작하는 건 안 건드렸다

1편에서 세운 원칙, "잘 되는 건 건드리지 않는다"를 여기서도 지켰다.

| API | 변경 여부 | 이유 |
|-----|-----------|------|
| `GET /v1/push/guardian/notification` | 변경 없음 | `pushNotificationType` 필터 이미 구현됨 |
| `GET /v1/push/staff/notification` | 변경 없음 | 동일 |
| `GET /v1/push/new-notification` | 변경 없음 | 미읽음 카운트 정상 동작 |
| `PATCH /v1/push/notification/read/{id}` | 변경 없음 | 읽음 처리 정상 |
| `POST /v1/fcm/check_update` | 변경 없음 | 앱 시작 시 디바이스 등록 용도로 유지 |

알림 목록 API에서 `pushNotificationType` 필터가 이미 구현되어 있었다는 건 의외의 발견이었다. 백엔드에는 준비가 되어 있는데 프론트에서 안 쓰고 있었던 거다. 서비스/마케팅 탭 분류는 프론트에서 파라미터만 바꿔 보내면 바로 동작하는 상태였다.

## 30종+ 푸시 타입의 세계

레거시 발송 이력을 분석해보니 푸시 타입이 30종이 넘었다:

```
매칭 관련: MATCHING_GUARDIAN_COMPLETE, MATCHING_STAFF_COMPLETE, REJECT_*_MATCHING ...
돌봄일지: NEW_CARE_LOG, CHANGE_CARE_LOG, COMMENT_CARE_LOG ...
복약:     NEW_MEDICATION_LOG, COMPLETE_MEDICATION ...
동행:     DEPARTURE/ARRIVAL/COME_BACK_COMPANION
기타:     BEFORE_SERVICE_START, REQUEST_CALL ...
```

이 모든 타입이 SERVICE 카테고리에 속한다. MARKETING 카테고리는 아직 비어있는데, 향후 프로모션이나 이벤트 푸시가 추가되면 사용할 예정이다. 지금 구조를 잡아놓으면 나중에 마케팅 푸시를 넣을 때 `notificationType: "MARKETING"`만 지정하면 된다.

## 이번 편을 마치며

푸시 알림은 사용자 경험의 핵심인데, 레거시 상태가 생각보다 심각했다. 수신 동의 무시, 토큰 소유자 불명, 발송 이력 부재 — 이 세 가지가 동시에 존재했다.

기획자 시절에는 "푸시 보내주세요"라고만 했지, 토큰이 어떻게 관리되고 수신 동의가 어떻게 체크되는지는 신경 쓸 일이 없었다. 직접 코드를 보니까 "아, 이게 이렇게 복잡한 거구나"라는 걸 체감했다.

다음 편에서는 이 백엔드 변경을 프론트엔드에 어떻게 연결했는지 — 특히 Native 앱과 WebView 사이에서 FCM 토큰을 주고받는 브릿지 구조에 대해 이야기해보겠다.

---

> **다음 편**: [[백엔드 도전기 6편 - Native앱과 WebView 사이에서 FCM 토큰 살리기]]
