---
title: "[기획자의 개발 도전기] 2편 - 80컬럼짜리 괴물 테이블을 세 조각으로 나누다"
description: "80컬럼짜리 매칭 테이블을 요청·활성·종료 3개로 분리한 DB 리팩토링기. 상태 머신 정의, 스냅샷 전략, 일정 중복 체크까지 — 도메인 지식이 설계에서 빛나는 순간."
date: 2026-01-05
tags:
  - 바이브코딩
  - 리팩토링
  - 매칭시스템
  - DB설계
  - 상태머신
---

# 80컬럼짜리 괴물 테이블을 세 조각으로 나누다

## 괴물을 마주하다

백엔드 코드를 처음 열어봤을 때의 충격을 아직도 기억한다.

`matching`이라는 테이블 하나에 컬럼이 **80개가 넘었다.** 매칭 요청부터 수락, 진행, 종료까지 — 매칭의 전체 생명주기를 하나의 레코드에 전부 담고 있었다. `matchingStatus`라는 상태값 하나로 이 모든 단계를 구분하고 있었는데, 분기가 10개 이상이라 코드를 읽는 것만으로도 머리가 아팠다.

문제는 그뿐이 아니었다.

- 단계별로 채워지는 필드가 대부분 **nullable**이었다. 요청 단계에서는 종료 관련 필드가 전부 NULL이고, 종료 단계에서는 요청 관련 필드 일부가 또 NULL이고. 어느 필드에 데이터가 있어야 정상인지 테이블만 봐서는 알 수가 없었다.
- 보조 테이블이 4개나 딸려 있었다. `matching_history`, `matching_address`, `matching_related_person`, `staff_hidden_matching`. 메인 테이블에 80개 컬럼을 쑤셔넣으면서 왜 보조 테이블을 또 만든 건지 납득이 안 됐다.
- 가장 치명적이었던 건 **변경 추적이 안 된다는 점**이었다. 보호자가 매칭 요청을 보낼 때 어르신 정보가 "서울시 강남구"였는데, 나중에 어르신 주소를 수정하면 매칭 기록에서도 바뀐 주소가 보인다. 요청 당시 시점의 정보가 사라지는 거다.

기획자 시절에는 "매칭 상태가 좀 복잡하네요"라고 가볍게 넘겼던 부분이었는데, 실제 코드와 데이터를 보니 이건 복잡한 게 아니라 **설계 자체가 잘못된 것**이었다.

## 핵심 질문: 매칭이란 뭔가

코드를 뜯어보기 전에, 기획자답게 먼저 도메인부터 정리했다. 우리 서비스에서 "매칭"은 어떤 생명주기를 갖는가?

```
보호자가 케어매니저에게 매칭을 요청한다
  → 케어매니저가 수락하거나 거절한다
    → 관리자가 최종 승인한다
      → 서비스가 진행된다
        → 어느 쪽이든 종료를 요청한다
          → 상대방이 수락하면 끝
```

이걸 보니 답이 보였다. 매칭은 하나의 상태가 아니라 **명확히 구분되는 3개의 단계**다.

1. **요청 단계** — 매칭을 신청하고 협의하는 과정
2. **활성 단계** — 실제 돌봄 서비스가 진행되는 기간
3. **종료 단계** — 서비스를 끝내기 위한 합의 과정

이 세 단계를 한 테이블에 넣은 게 문제의 근본 원인이었다.

## 3테이블 분리 아키텍처

결정을 내렸다. 매칭 테이블을 세 조각으로 나눈다.

```
matching_request ──(승인)──> matching_complete ──(종료 합의)──> matching_terminate
  [요청 단계]                  [활성 서비스]                     [종료 프로세스]
```

### matching_request — 요청 단계

보호자가 케어매니저에게 매칭을 요청하면 여기에 레코드가 생긴다. 케어매니저가 수락하고, 관리자가 최종 승인할 때까지의 과정을 담는다.

### matching_complete — 활성 서비스

관리자 승인이 떨어지면 이 테이블에 새 레코드가 만들어진다. 실제로 서비스가 진행 중인 매칭만 여기에 존재한다. 서비스 요일, 시간, 주소 같은 운영 정보가 들어간다.

### matching_terminate — 종료 프로세스

종료 요청을 보내면 이 테이블에 기록된다. 상대방이 수락할 때까지, 또는 7일이 지나 자동 종료될 때까지의 과정을 관리한다.

테이블 간 관계는 이렇다:

- `matching_complete.matching_request_id`는 **UNIQUE KEY** — 하나의 요청에 하나의 활성 매칭만 존재
- `matching_terminate.matching_complete_id`는 **FK** — 종료가 거절되면 다시 요청할 수 있으니 1:N

## 상태 머신을 명확하게

기존에는 `matchingStatus` 하나에 10개 이상의 상태가 뒤섞여 있었다. 이걸 각 테이블별로 분리하니 상태 관리가 훨씬 깔끔해졌다.

**matching_request 상태 흐름:**

```
REQUEST_SUBMITTED (매칭 신청)
    ├── 케어매니저 수락 → REVIEW_PENDING (검토 대기)
    │                        ├── 관리자 승인 → APPROVED ✓
    │                        └── 관리자 거절 → REJECTED ✗
    ├── 케어매니저 거절 → REJECTED ✗
    └── 관리자 거절 → REJECTED ✗
```

**matching_terminate 상태 흐름:**

```
TERMINATE_SUBMITTED (종료 접수)
    ├── 상대방 수락 → TERMINATE_COMPLETED ✓ (+ matching_complete 삭제)
    ├── 상대방 거절 → TERMINATE_REJECTED ✗
    └── 7일 무응답 → TERMINATE_COMPLETED ✓ (자동 종료)
```

각 테이블이 자기 단계의 상태만 관리하니, 코드에서 분기 처리가 크게 줄었다. 이전에는 "이 상태일 때 이 필드는 NULL이어야 하고 저 필드는 값이 있어야 하고..."를 머릿속으로 추적해야 했는데, 이제는 테이블 자체가 단계를 구분해준다.

## 시점 데이터를 보존하는 스냅샷 전략

기존 구조에서 가장 짜증났던 문제가 변경 추적이 안 되는 것이었다. 이걸 해결하기 위해 **스냅샷 전략**을 도입했다.

핵심 아이디어는 간단하다. 매칭 요청 시점에 보호자, 어르신, 케어매니저의 정보를 **그대로 복사해서 저장**하는 것이다. 원본이 나중에 바뀌더라도 요청 당시의 정보가 보존된다.

스냅샷 빌더를 세 종류 만들었다:

**보호자 스냅샷** — member 테이블에서 기본 정보를 복사

| 스냅샷 필드 | 원본 |
|-------------|------|
| guardianName | member.name |
| guardianPhone | member.mobilePhoneNo |

**어르신 스냅샷** — ward 테이블에서 돌봄 관련 정보를 통째로 복사

이름, 성별, 생년월일, 장기요양등급, 서비스 주소, 희망 요일/시간까지 14개 필드를 스냅샷한다. wardId가 null이면 (어르신을 아직 지정하지 않은 경우) 스냅샷을 생성하지 않는다.

**케어매니저 스냅샷** — member, staff, staff_profile 3개 테이블에서 병렬 조회하여 복사

이름, 연락처, 자격증, 경력은 물론이고 서비스 가능 지역, 희망 요일/시간대까지 포함한다.

그리고 이 스냅샷이 매칭 생명주기를 따라 전파된다:

```
[1단계] matching_request 생성 시
    → 보호자 + 어르신 + 케어매니저 스냅샷 저장

[2단계] matching_complete 생성 시 (관리자 승인)
    → matching_request의 스냅샷을 그대로 복사 + 서비스 일정 추가

[3단계] matching_terminate 생성 시 (종료 요청)
    → matching_complete 레코드를 통째로 복사
```

이렇게 하니 "2025년 1월에 요청했을 때 어르신 주소가 어디였지?"같은 질문에 바로 답할 수 있게 됐다. 운영 입장에서 이건 정말 큰 차이다.

## 일정 중복 체크

활성 매칭에서 중요한 비즈니스 룰이 하나 있다. **같은 어르신에게 서비스 일정이 겹치는 매칭이 동시에 존재하면 안 된다.**

예를 들어:

```
기존 매칭: 김 매니저 — 월,수,금 09:00~12:00
신규 매칭: 이 매니저 — 월,화 10:00~14:00
```

월요일 10:00~12:00 구간이 겹친다. 이런 경우를 잡아야 한다.

`checkScheduleConflict` 함수를 만들어서 관리자 승인 시(`/approve`)와 일정 수정 시(`/schedule`) 두 곳에서 호출하도록 했다.

검증 로직은 2단계다:

1. **요일 비교**: 신규 요일과 기존 요일의 교집합을 구한다. 교집합이 없으면 패스.
2. **시간 비교**: 교집합이 있으면 시간이 겹치는지 확인한다. `newStart < existingEnd AND existingStart < newEnd`이면 충돌.

기획할 때는 "일정 겹치면 안 돼요"라고 한 줄 쓰면 되지만, 코드로 구현하려면 요일 교집합 계산, 시간대 비교, 자기 자신 수정 시 제외 처리(excludeId) 같은 세부사항이 꽤 많다. 직접 구현해보니 기획서에 "일정 중복 체크" 한 줄 쓰고 개발팀에 넘겼던 과거가 좀 미안해졌다.

## 7일 자동 종료

종료 프로세스에서 한 가지 고민이 있었다. 한쪽이 종료를 요청했는데 상대방이 아무 응답을 안 하면 어떻게 되는가?

답은 **7일 무응답 시 자동 종료**다. Vercel Cron을 이용해서 매일 한 번 실행되는 배치를 만들었다.

```
매일 00:00 실행
  → requestedAt이 7일 이전인 TERMINATE_SUBMITTED 건 조회
  → 각 건을 트랜잭션으로 처리:
     - terminateStatus → TERMINATE_COMPLETED
     - matching_complete 레코드 삭제
  → 개별 건 실패 시 해당 건만 스킵하고 나머지 계속 처리
```

여기서 포인트는 **개별 건 실패 시 전체를 롤백하지 않는다**는 것이다. 10건 중 1건이 실패했다고 나머지 9건까지 처리 안 하면 곤란하니까. 이건 실제로 운영해보면서 느낀 부분인데, 배치 작업에서 all-or-nothing은 위험하다.

인증도 일반 API와 다르게 처리했다. 사용자의 JWT가 아니라 `x-cron-secret` 헤더로 환경변수와 매칭하는 시스템 전용 인증을 사용한다.

## 레거시 15개 API를 삭제하다

신규 매칭 여정 API 17개가 안정되자, 기존 레거시 매칭 API 15개를 코드에서 삭제했다. `v1/matching/*`, `v2/matching/*`(레거시 v2), `v2/guardian/matchings` 전부.

Prisma schema에서도 보조 모델 4개를 제거했다:

- `MatchingHistory` — 상태 변경 이력
- `MatchingAddress` — 매칭 주소
- `MatchingRelatedPerson` — 관련 인물
- `StaffHiddenMatching` — 케어매니저 숨긴 매칭

다만 `matching` 테이블 자체는 아직 삭제하지 못했다. `care_log`와 `product_amount` 테이블에서 FK로 참조하고 있어서다. 이건 돌봄 소통 서비스 리팩토링에서 의존성을 끊은 후에 처리할 계획이다. (4편에서 이어진다.)

## 이번 편을 마치며

80컬럼짜리 하나의 테이블을 3개로 나누는 작업이 이 프로젝트에서 가장 큰 도전이었다. 기존 데이터 구조를 이해하고, 새 구조를 설계하고, 스냅샷 전략을 세우고, 상태 머신을 정의하고, 일정 중복 체크와 자동 종료까지 — 기획서 한 장으로는 절대 담을 수 없는 깊이가 있었다.

기획자로서 가장 놀라웠던 건, **도메인 지식이 코드 설계에서 진짜 힘을 발휘한다는 것**이었다. "매칭은 요청, 활성, 종료 세 단계다"라는 건 우리 서비스를 잘 아는 사람이면 자연스럽게 나오는 결론인데, 코드로는 80컬럼 하나의 테이블로 구현되어 있었다. 도메인을 모르는 개발자가 만들면 이런 일이 생기는구나, 하는 걸 절감했다.

다음 편에서는 회원 프로필 시스템을 어떻게 정리했는지 이야기해보겠다.

---

> **다음 편**: [[백엔드 도전기 3편 - 흩어진 회원 프로필을 정리하고 검색을 개선하다]]
