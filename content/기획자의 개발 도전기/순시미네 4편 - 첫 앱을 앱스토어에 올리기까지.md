---
title: "[기획자의 개발 도전기] 순시미네 4편 - 첫 앱을 앱스토어에 올리기까지"
date: 2026-02-26
tags:
  - 바이브코딩
  - Flutter
  - Supabase
  - Firebase
  - 앱스토어배포
---

# 첫 앱을 앱스토어에 올리기까지

## 코드 완성이 끝이 아니었다

[[순시미네 3편 - AI 추천부터 커뮤니티까지, 서비스에 살을 붙이다|이전 편]]까지 기능을 다 만들었다. 지도, AI 추천, 커뮤니티, 게이미피케이션. 앱을 돌려보면 잘 동작한다. 이제 스토어에 올리면 끝이겠지?

아니었다.

"코드 다 짰으니까 빌드해서 올리면 되겠지?"라고 생각했는데, 앱스토어 배포까지의 과정은 코딩과는 완전히 다른 영역이었다. 인증서, 프로비저닝 프로파일, 스크린샷, 심사 가이드라인, 개인정보 처리방침...

기획서에서 "스토어 배포" 한 줄이 실무에서는 2주짜리 작업이 됐다.

## Supabase와 Firebase 사이에서

순시미네의 백엔드 구조를 보면 좀 독특하다. **Supabase와 Firebase를 동시에 쓴다.**

```
┌────────────────────────────────────────────┐
│                순시미네 앱                    │
├──────────────────┬─────────────────────────┤
│   Supabase       │    Firebase             │
│  (주 백엔드)       │   (보조 서비스)           │
│                  │                         │
│  ✅ 회원 정보      │  ✅ FCM 푸시 알림         │
│  ✅ 시설 데이터    │  ✅ Remote Config        │
│  ✅ 커뮤니티      │  ✅ Analytics            │
│  ✅ 점수/레벨     │  ✅ 즐겨찾기 (Firestore)  │
│  ✅ PostGIS 검색  │  ✅ AI 분석 결과 저장     │
│  ✅ 이미지 저장    │                         │
│  ✅ Edge Function │                         │
│  ✅ Realtime     │                         │
└──────────────────┴─────────────────────────┘
```

왜 이렇게 됐을까? 솔직히 말하면, **처음부터 계획한 게 아니다.**

초기에는 Supabase 하나로 다 하려고 했다. 그런데 개발하다 보니 필요한 것들이 하나둘 생겼다. 푸시 알림은 Firebase Cloud Messaging이 표준이고, 앱 설정을 원격으로 바꾸는 건 Firebase Remote Config가 편했고, 앱 사용 분석은 Firebase Analytics가 이미 Flutter에 잘 통합되어 있었다.

그러다 즐겨찾기 기능을 만들 때, "빠르게 읽고 쓰는 간단한 데이터"를 위해 Firestore를 써봤다. 관계형 스키마가 필요 없는 단순 데이터니까. 이게 하나 시작되니까 AI 분석 결과도 Firestore에 넣게 되고...

결과적으로 **관계형 데이터는 Supabase, 비관계형/서비스 데이터는 Firebase**라는 이중 구조가 되었다. 깔끔하지는 않지만, 각자의 강점을 활용한 실용적인 선택이었다고 생각한다.

다만 이로 인한 복잡성도 있었다:

| 문제 | 상황 |
|------|------|
| 환경 분리 | Supabase dev/prod + Firebase dev/prod = 관리 포인트 4개 |
| 데이터 일관성 | 회원은 Supabase인데 즐겨찾기는 Firestore, memberId로 교차 참조 |
| 컬렉션 네이밍 | 개발 환경에서 `dev_` 접두어로 Firestore 컬렉션 분리 필요 |

`AppConfig`에서 `dart.vm.product` 플래그로 개발/운영을 판별하고, Firestore 컬렉션명에 `dev_` 접두어를 동적으로 붙이는 식으로 해결했다. 별거 아닌 것 같지만, 이걸 안 하면 개발 중에 운영 데이터를 건드리는 사고가 날 수 있다. 실제로 한번 그랬다.

지금 다시 만든다면? 아마 Supabase 하나로 통일할 것 같다. 하지만 그때는 빠르게 만드는 게 우선이었고, "동작하는 코드"가 "깔끔한 아키텍처"보다 중요했다.

## iOS vs Android — 같은 코드, 다른 세계

Flutter는 "한 번 짜면 iOS, Android 둘 다 된다"고 한다. 맞는 말이긴 한데, **"된다"와 "완벽하게 동일하게 동작한다"는 다른 말**이다.

### 플랫폼별 차이점

```
차이가 났던 부분들:

1. 초기화 타이밍
   iOS:     앱 시작 즉시 지도/위치 서비스 초기화 가능
   Android: addPostFrameCallback으로 지연 초기화 필요
            (렌더링 완료 전 초기화하면 크래시)

2. 푸시 알림
   iOS:     APNs → FCM 자동 연동
   Android: FCM 직접 처리, 7일 주기 토큰 리프레시 필요
            (토큰 만료 시 needs_refresh 플래그로 관리)

3. 소셜 로그인
   iOS:     애플 로그인 필수 (App Store 가이드라인)
   Android: 애플 로그인 선택
   공통:     카카오/네이버는 양 플랫폼 동일

4. 위치 권한
   iOS:     "앱 사용 중" / "항상 허용" 구분 명확
   Android: 정밀 위치 / 대략적 위치 + 백그라운드 구분
```

Android 푸시 알림은 특히 까다로웠다. FCM 토큰이 주기적으로 만료되는데, 이걸 감지하고 갱신하는 로직이 필요했다. DB에 `needs_refresh` 플래그와 `last_error` 컬럼을 두고, 앱 시작 시 토큰 상태를 확인하는 프로세스를 만들었다.

```
앱 시작 시 FCM 토큰 체크 흐름:

1. 로컬 저장 토큰과 FCM 서버 토큰 비교
2. 불일치? → DB에서 기존 토큰 레코드 삭제
3. 새 토큰으로 재등록
4. DB의 needs_refresh 플래그 확인
5. 플래그 true? → 토큰 갱신 후 플래그 리셋
```

이 FCM 토큰 관리 경험이 나중에 기존 서비스(순시미)의 푸시 알림 시스템을 리팩토링할 때 큰 도움이 됐다. 토큰 라이프사이클을 이미 한 번 겪어봤으니까. [[5편 - 푸시 알림 시스템, 뜯어보니 구멍투성이였다|기획자의 개발 도전기_2]]에서 "토큰에 주인이 없다"는 문제를 바로 알아챈 것도 이 경험 덕분이다.

## 앱스토어 심사 — 마스터 로그인의 탄생

iOS App Store와 Google Play에 앱을 제출하면 **심사**를 거쳐야 한다. 심사관이 직접 앱을 실행해보고 문제가 없는지 확인하는 과정이다.

문제는 우리 앱이 **소셜 로그인만** 지원한다는 것이었다. 심사관이 카카오나 네이버 계정을 만들어서 로그인할 리가 없다.

그래서 **마스터 로그인**을 만들었다. 특별한 테스트 계정으로 소셜 인증 없이 로그인할 수 있는 기능이다.

```
마스터 로그인 동작 방식:

1. Firebase Remote Config에서 마스터 계정 정보 로드
   {
     "enabled": true,
     "platforms": ["ios"],      // iOS 심사 중일 때만
     "versions": ["1.1.3"],     // 심사 대상 버전만
     "email": "review@...",
     "password": "..."
   }

2. 조건 충족 시 로그인 화면에 마스터 로그인 버튼 표시

3. 심사 완료 후 Remote Config에서 비활성화
   → 앱 업데이트 없이 즉시 마스터 로그인 제거
```

핵심은 **앱을 업데이트하지 않고도 마스터 로그인을 켜고 끌 수 있다**는 것이다. Firebase Remote Config을 쓰니까, 서버에서 설정만 바꾸면 된다. 심사 중일 때만 켜고, 통과하면 바로 끈다.

플랫폼별, 버전별로 제어할 수 있어서 "iOS 1.1.3 심사 중"이면 해당 조건에서만 마스터 로그인이 보인다. Android는 영향 없다. 이전 버전에서도 안 보인다.

이 아이디어는 기획자 출신이라 할 수 있었다고 생각한다. 개발자라면 빌드 분기나 환경 변수로 처리했을 텐데, 나는 "운영 중에 실시간으로 바꿀 수 있어야 한다"는 운영 관점에서 접근했다.

## Remote Config으로 약관을 관리하다

마스터 로그인뿐 아니라, **약관 관리**에도 Remote Config을 활용했다.

서비스 이용약관, 개인정보 처리방침, 위치정보 이용약관 — 이런 문서들은 법적 요구사항에 따라 수시로 변경될 수 있다. 매번 앱을 업데이트해서 반영하면 심사도 다시 받아야 하고, 사용자도 업데이트해야 한다.

```
Remote Config 약관 구조:

terms_of_service: {
  version: "2025-08-01",
  content: "제1조 (목적)..."
}

privacy_policy: {
  version: "2025-08-01",
  content: "1. 개인정보의 처리 목적..."
}

location_terms: {
  version: "2025-08-01",
  content: "제1조 (목적)..."
}
```

약관 버전이 바뀌면, 앱이 시작될 때 이를 감지하고 새로운 약관 동의 화면을 표시한다. 앱 업데이트 없이 약관을 변경할 수 있다.

이것도 기획자 감각이 통한 부분이다. "약관이 바뀌면 어떻게 하지?"는 기획할 때 항상 고려하던 문제였는데, 직접 구현하니까 Remote Config이라는 깔끔한 해법이 보였다.

## 스토어 제출, 그리고 리젝

첫 스토어 제출에서 바로 통과하지는 못했다. iOS App Store에서 리젝 사유가 왔다.

기억나는 리젝 사유들:

1. **개인정보 수집 명시 부족** — 위치 정보를 왜 수집하는지 앱 내에서 충분히 설명하지 않았다
2. **로그인 없이 사용 가능한 기능 부재** — 심사관이 소셜 로그인을 못 하니 앱을 아예 못 봤다 (→ 마스터 로그인 탄생의 계기)
3. **스크린샷 해상도 미달** — 기기별 요구 해상도가 다르다

하나씩 고치고 다시 제출하고, 또 리젝되고, 또 고치고... 이 과정을 3번 반복했다.

Google Play는 상대적으로 수월했다. 심사 기준이 iOS보다 느슨한 편이고, 마스터 로그인 정보를 제출 시 함께 제공할 수 있는 필드가 있어서 소셜 로그인 문제도 쉽게 해결됐다.

## 돌아보며 — 첫 바이브 코딩이 남긴 것

순시미네는 내 첫 바이브 코딩 프로젝트다. 기획만 하던 사람이 Flutter와 Supabase를 잡고, 디자이너 한 명과 함께, 앱스토어에 올라가는 앱을 만들었다.

숫자로 정리하면:

| 항목 | 수치 |
|------|------|
| 화면 수 | 25개 이상 |
| 서비스 클래스 | 25개 이상 |
| 데이터 모델 | 16개 |
| Supabase 마이그레이션 | 35개 이상 |
| 소셜 로그인 | 3종 (카카오/네이버/애플) |
| 하단 탭 | 4개 (지도/AI/커뮤니티/마이페이지) |

잘한 것과 아쉬운 것이 분명하다.

**잘한 것:**
- **Supabase + PostGIS 선택** — 위치 기반 서비스에 최적이었다
- **AI 추천 쿨타임** — 비용 제어와 UX를 동시에 잡았다
- **Remote Config 활용** — 앱 업데이트 없이 운영 제어가 가능해졌다
- **게이미피케이션** — 사용자 활동 유도에 효과적이었다

**아쉬운 것:**
- **이중 백엔드** — Supabase와 Firebase가 혼재하면서 관리 복잡도가 높아졌다
- **상태관리 부재** — 싱글톤 서비스 패턴은 간단하지만 확장성에 한계가 있다
- **테스트 코드 없음** — 바이브 코딩의 속도에 치여 테스트를 하나도 안 썼다

그래도 이 프로젝트가 나에게 준 가장 큰 자산은 **"나도 만들 수 있다"는 자신감**이다. 이 자신감이 있었기 때문에, 이후 회사의 기존 서비스 백엔드를 직접 리팩토링하겠다는 결심을 할 수 있었다. 그게 바로 [[1편 - 기획자가 왜 백엔드를 뜯어고치게 되었나|기획자의 개발 도전기_1]]의 시작이다.

기획서를 쓰는 것과 코드를 쓰는 건 정말 다르다. 하지만 둘 다 결국 **"사용자에게 가치를 전달한다"**는 같은 목표를 향한다. 10년의 기획 경험이 코드를 짜는 데 쓸모없지 않았다. 오히려 "무엇을 만들어야 하는지"를 정확히 아는 것이, 바이브 코딩에서 가장 강력한 무기였다.

---

> **이전 편**: [[순시미네 3편 - AI 추천부터 커뮤니티까지, 서비스에 살을 붙이다]]
> **다음 시리즈**: [[1편 - 기획자가 왜 백엔드를 뜯어고치게 되었나|기획자의 개발 도전기_1 →]]
